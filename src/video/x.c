
//#1 "SDL_RLEaccel.c"
 


























 














 

















































//#1 "/usr/include/stdio.h" 1 3
 

















 







//#1 "/usr/include/features.h" 1 3
 




















 



























































 



















 





 



 







 
//#138 "/usr/include/features.h" 3


 









 





 



























//#196 "/usr/include/features.h" 3


































 



 








 




 

//#1 "/usr/include/sys/cdefs.h" 1 3
 




















 




 





 








 




//#71 "/usr/include/sys/cdefs.h" 3


 







 



//#103 "/usr/include/sys/cdefs.h" 3



 








 















 








 








 









 







//#250 "/usr/include/features.h" 2 3


 








 





 

 








//#1 "/usr/include/gnu/stubs.h" 1 3
 






































//#278 "/usr/include/features.h" 2 3




//#27 "/usr/include/stdio.h" 2 3


 



//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


































typedef unsigned int size_t;






















 




 

//#271 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


//#283 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#33 "/usr/include/stdio.h" 2 3





//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stdarg.h" 1 3
 
































































 






typedef void *__gnuc_va_list;



 

//#122 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stdarg.h" 3




















//#209 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stdarg.h" 3




//#38 "/usr/include/stdio.h" 2 3


//#1 "/usr/include/bits/types.h" 1 3
 

















 









//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


//#188 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3





 




 

//#271 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


//#283 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#29 "/usr/include/bits/types.h" 2 3


 
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;

__extension__ typedef unsigned long long int __u_quad_t;
__extension__ typedef long long int __quad_t;
//#48 "/usr/include/bits/types.h" 3

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;

typedef __quad_t *__qaddr_t;

typedef __u_quad_t __dev_t;		 
typedef __u_int __uid_t;		 
typedef __u_int __gid_t;		 
typedef __u_long __ino_t;		 
typedef __u_int __mode_t;		 
typedef __u_int __nlink_t; 		 
typedef long int __off_t;		 
typedef __quad_t __loff_t;		 
typedef int __pid_t;			 
typedef int __ssize_t;			 
typedef __u_long __rlim_t;		 
typedef __u_quad_t __rlim64_t;		 
typedef __u_int __id_t;			 

typedef struct
  {
    int __val[2];
  } __fsid_t;				 

 
typedef int __daddr_t;			 
typedef char *__caddr_t;
typedef long int __time_t;
typedef long int __swblk_t;		 

typedef long int __clock_t;

 
typedef unsigned long int __fd_mask;

 


 




 
typedef struct
  {
     





    __fd_mask __fds_bits[1024  / (8 * sizeof (__fd_mask)) ];


  } __fd_set;


typedef int __key_t;

 
typedef unsigned short int __ipc_pid_t;


 

 
typedef long int __blkcnt_t;
typedef __quad_t __blkcnt64_t;

 
typedef __u_long __fsblkcnt_t;
typedef __u_quad_t __fsblkcnt64_t;

 
typedef __u_long __fsfilcnt_t;
typedef __u_quad_t __fsfilcnt64_t;

 
typedef __u_long __ino64_t;

 
typedef __loff_t __off64_t;

 
typedef long int __t_scalar_t;
typedef unsigned long int __t_uscalar_t;

 
typedef int __intptr_t;


 





//#40 "/usr/include/stdio.h" 2 3







 
typedef struct _IO_FILE FILE;








//#1 "/usr/include/libio.h" 1 3
 




























//#1 "/usr/include/_G_config.h" 1 3
 





 






//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


//#188 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3





 




 





























 


























typedef short int wchar_t;
























typedef unsigned int  wint_t;




 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#14 "/usr/include/_G_config.h" 2 3





















typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));




 


















 




 














//#30 "/usr/include/libio.h" 2 3
















 

//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stdarg.h" 1 3
 
































































 










 

//#122 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stdarg.h" 3




















//#209 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stdarg.h" 3




//#48 "/usr/include/libio.h" 2 3







//#67 "/usr/include/libio.h" 3


 

















//#98 "/usr/include/libio.h" 3











 
























 



















struct _IO_jump_t;  struct _IO_FILE;

 







typedef void _IO_lock_t;



 

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
   

   
  int _pos;
//#186 "/usr/include/libio.h" 3

};

struct _IO_FILE {
  int _flags;		 


   
   
  char* _IO_read_ptr;	 
  char* _IO_read_end;	 
  char* _IO_read_base;	 
  char* _IO_write_base;	 
  char* _IO_write_ptr;	 
  char* _IO_write_end;	 
  char* _IO_buf_base;	 
  char* _IO_buf_end;	 
   
  char *_IO_save_base;  
  char *_IO_backup_base;   
  char *_IO_save_end;  

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _blksize;
  __off_t   _old_offset;  


   
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

   

  _IO_lock_t *_lock;








  __off64_t   _offset;
   
  int _unused2[16];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;
extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;











 

 

typedef __ssize_t __io_read_fn  (void *  __cookie, char *__buf,
				       size_t __nbytes)  ;

 





typedef __ssize_t __io_write_fn  (void *  __cookie, __const char *__buf,
				      size_t __n)  ;

 





typedef int __io_seek_fn  (void *  __cookie, __off_t   __pos, int __w)  ;

 
typedef int __io_close_fn  (void *  __cookie)  ;


//#311 "/usr/include/libio.h" 3







extern int __underflow  (_IO_FILE *)    ;
extern int __uflow  (_IO_FILE *)    ;
extern int __overflow  (_IO_FILE *, int)    ;
















extern int _IO_getc  (_IO_FILE *__fp)    ;
extern int _IO_putc  (int __c, _IO_FILE *__fp)    ;
extern int _IO_feof  (_IO_FILE *__fp)    ;
extern int _IO_ferror  (_IO_FILE *__fp)    ;

extern int _IO_peekc_locked  (_IO_FILE *__fp)    ;

 



extern void _IO_flockfile  (_IO_FILE *)    ;
extern void _IO_funlockfile  (_IO_FILE *)    ;
extern int _IO_ftrylockfile  (_IO_FILE *)    ;












extern int _IO_vfscanf  (_IO_FILE * __restrict, const char * __restrict,
			     __gnuc_va_list , int *__restrict)    ;
extern int _IO_vfprintf  (_IO_FILE *__restrict, const char *__restrict,
			      __gnuc_va_list )    ;
extern __ssize_t   _IO_padn  (_IO_FILE *, int, __ssize_t  )    ;
extern size_t   _IO_sgetn  (_IO_FILE *, void *, size_t  )    ;

extern __off64_t   _IO_seekoff  (_IO_FILE *, __off64_t  , int, int)    ;
extern __off64_t   _IO_seekpos  (_IO_FILE *, __off64_t  , int)    ;

extern void _IO_free_backup_area  (_IO_FILE *)    ;






//#57 "/usr/include/stdio.h" 2 3


 

typedef __off_t  fpos_t;







 





 





 






 







 




 








//#1 "/usr/include/bits/stdio_lim.h" 1 3
 




































//#110 "/usr/include/stdio.h" 2 3



 
extern FILE *stdin;		 
extern FILE *stdout;		 
extern FILE *stderr;		 
 





 
extern int remove  (__const char *__filename)    ;
 
extern int rename  (__const char *__old, __const char *__new)    ;


 

extern FILE *tmpfile  (void)    ;










 
extern char *tmpnam  (char *__s)    ;


 

extern char *tmpnam_r  (char *__s)    ;




 






extern char *tempnam  (__const char *__dir, __const char *__pfx)    ;



 
extern int fclose  (FILE *__stream)    ;
 
extern int fflush  (FILE *__stream)    ;


 
extern int fflush_unlocked  (FILE *__stream)    ;









 
extern FILE *fopen  (__const char *__restrict __filename,
			 __const char *__restrict __modes)    ;
 
extern FILE *freopen  (__const char *__restrict __filename,
			   __const char *__restrict __modes,
			   FILE *__restrict __stream)    ;
//#201 "/usr/include/stdio.h" 3










 
extern FILE *fdopen  (int __fd, __const char *__modes)    ;


//#227 "/usr/include/stdio.h" 3



 

extern void setbuf  (FILE *__restrict __stream, char *__restrict __buf)    ;
 


extern int setvbuf  (FILE *__restrict __stream, char *__restrict __buf,
			 int __modes, size_t __n)    ;


 

extern void setbuffer  (FILE *__restrict __stream, char *__restrict __buf,
			    size_t __size)    ;

 
extern void setlinebuf  (FILE *__stream)    ;



 
extern int fprintf  (FILE *__restrict __stream,
			 __const char *__restrict __format, ...)    ;
 
extern int printf  (__const char *__restrict __format, ...)    ;
 
extern int sprintf  (char *__restrict __s,
			 __const char *__restrict __format, ...)    ;

 
extern int vfprintf  (FILE *__restrict __s,
			  __const char *__restrict __format,
			  __gnuc_va_list  __arg)    ;
 
extern int vprintf  (__const char *__restrict __format,
			 __gnuc_va_list  __arg)    ;
 
extern int vsprintf  (char *__restrict __s,
			  __const char *__restrict __format,
			  __gnuc_va_list  __arg)    ;


 
extern int snprintf  (char *__restrict __s, size_t __maxlen,
			  __const char *__restrict __format, ...)    
     __attribute__ ((__format__ (__printf__, 3, 4)));

extern int __vsnprintf  (char *__restrict __s, size_t __maxlen,
			     __const char *__restrict __format,
			     __gnuc_va_list  __arg)    
     __attribute__ ((__format__ (__printf__, 3, 0)));
extern int vsnprintf  (char *__restrict __s, size_t __maxlen,
			   __const char *__restrict __format,
			   __gnuc_va_list  __arg)    
     __attribute__ ((__format__ (__printf__, 3, 0)));


//#306 "/usr/include/stdio.h" 3



 
extern int fscanf  (FILE *__restrict __stream,
			__const char *__restrict __format, ...)    ;
 
extern int scanf  (__const char *__restrict __format, ...)    ;
 
extern int sscanf  (__const char *__restrict __s,
			__const char *__restrict __format, ...)    ;

//#334 "/usr/include/stdio.h" 3



 
extern int fgetc  (FILE *__stream)    ;
extern int getc  (FILE *__stream)    ;

 
extern int getchar  (void)    ;

 




 
extern int getc_unlocked  (FILE *__stream)    ;
extern int getchar_unlocked  (void)    ;



 
extern int fgetc_unlocked  (FILE *__stream)    ;



 
extern int fputc  (int __c, FILE *__stream)    ;
extern int putc  (int __c, FILE *__stream)    ;

 
extern int putchar  (int __c)    ;

 




 
extern int fputc_unlocked  (int __c, FILE *__stream)    ;



 
extern int putc_unlocked  (int __c, FILE *__stream)    ;
extern int putchar_unlocked  (int __c)    ;




 
extern int getw  (FILE *__stream)    ;

 
extern int putw  (int __w, FILE *__stream)    ;



 
extern char *fgets  (char *__restrict __s, int __n,
			 FILE *__restrict __stream)    ;







 

extern char *gets  (char *__s)    ;


//#424 "/usr/include/stdio.h" 3



 
extern int fputs  (__const char *__restrict __s,
		       FILE *__restrict __stream)    ;







 
extern int puts  (__const char *__s)    ;


 
extern int ungetc  (int __c, FILE *__stream)    ;


 
extern size_t fread  (void *__restrict __ptr, size_t __size,
			  size_t __n, FILE *__restrict __stream)    ;
 
extern size_t fwrite  (__const void *__restrict __ptr, size_t __size,
			   size_t __n, FILE *__restrict __s)    ;


 
extern size_t fread_unlocked  (void *__restrict __ptr, size_t __size,
				   size_t __n, FILE *__restrict __stream)    ;
extern size_t fwrite_unlocked  (__const void *__restrict __ptr,
				    size_t __size, size_t __n,
				    FILE *__restrict __stream)    ;



 
extern int fseek  (FILE *__stream, long int __off, int __whence)    ;
 
extern long int ftell  (FILE *__stream)    ;
 
extern void rewind  (FILE *__stream)    ;

 




 


typedef __off_t off_t;




















 
extern int fgetpos  (FILE *__restrict __stream,
			 fpos_t *__restrict __pos)    ;
 
extern int fsetpos  (FILE *__stream, __const fpos_t *__pos)    ;
//#523 "/usr/include/stdio.h" 3


//#533 "/usr/include/stdio.h" 3


 
extern void clearerr  (FILE *__stream)    ;
 
extern int feof  (FILE *__stream)    ;
 
extern int ferror  (FILE *__stream)    ;


 
extern void clearerr_unlocked  (FILE *__stream)    ;
extern int feof_unlocked  (FILE *__stream)    ;
extern int ferror_unlocked  (FILE *__stream)    ;



 
extern void perror  (__const char *__s)    ;

 


extern int sys_nerr;
extern __const char *__const sys_errlist[];








 
extern int fileno  (FILE *__stream)    ;



 
extern int fileno_unlocked  (FILE *__stream)    ;





 
extern FILE *popen  (__const char *__command, __const char *__modes)    ;

 
extern int pclose  (FILE *__stream)    ;




 
extern char *ctermid  (char *__s)    ;









//#607 "/usr/include/stdio.h" 3




 

 
extern void flockfile  (FILE *__stream)    ;

 

extern int ftrylockfile  (FILE *__stream)    ;

 
extern void funlockfile  (FILE *__stream)    ;










 


//#1 "/usr/include/bits/stdio.h" 1 3
 





























 
extern __inline  int
vprintf (__const char *__restrict __fmt, __gnuc_va_list  __arg)  
{
  return vfprintf (stdout , __fmt, __arg);
}

 
extern __inline  int
getchar (void)  
{
  return _IO_getc (stdin );
}



 
extern __inline  int
getc_unlocked (FILE *__fp)  
{
  return (( __fp )->_IO_read_ptr >= ( __fp )->_IO_read_end ? __uflow ( __fp ) : *(unsigned char *) ( __fp )->_IO_read_ptr++) ;
}

 
extern __inline  int
getchar_unlocked (void)  
{
  return (( stdin  )->_IO_read_ptr >= ( stdin  )->_IO_read_end ? __uflow ( stdin  ) : *(unsigned char *) ( stdin  )->_IO_read_ptr++) ;
}



 
extern __inline  int
putchar (int __c)  
{
  return _IO_putc (__c, stdout );
}



 
extern __inline  int
fputc_unlocked (int __c, FILE *__stream)  
{
  return (((  __stream )->_IO_write_ptr >= (  __stream )->_IO_write_end) ? __overflow (  __stream , (unsigned char) ( __c )) : (unsigned char) (*(  __stream )->_IO_write_ptr++ = ( __c ))) ;
}




 
extern __inline  int
putc_unlocked (int __c, FILE *__stream)  
{
  return (((  __stream )->_IO_write_ptr >= (  __stream )->_IO_write_end) ? __overflow (  __stream , (unsigned char) ( __c )) : (unsigned char) (*(  __stream )->_IO_write_ptr++ = ( __c ))) ;
}

 
extern __inline  int
putchar_unlocked (int __c)  
{
  return (((  stdout  )->_IO_write_ptr >= (  stdout  )->_IO_write_end) ? __overflow (  stdout  , (unsigned char) ( __c )) : (unsigned char) (*(  stdout  )->_IO_write_ptr++ = ( __c ))) ;
}














 
extern __inline  int
feof_unlocked (FILE *__stream)  
{
  return ((( __stream )->_flags & 0x10 ) != 0) ;
}

 
extern __inline  int
ferror_unlocked (FILE *__stream)  
{
  return ((( __stream )->_flags & 0x20 ) != 0) ;
}






 

//#149 "/usr/include/bits/stdio.h" 3


//#165 "/usr/include/bits/stdio.h" 3


 

//#635 "/usr/include/stdio.h" 2 3



 




//#93 "SDL_RLEaccel.c" 2

//#1 "/usr/include/stdlib.h" 1 3
 

















 







 





//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


//#188 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3





 




 


//#269 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




//#283 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#33 "/usr/include/stdlib.h" 2 3


 




 
typedef struct
  {
    int quot;			 
    int rem;			 
  } div_t;

 

typedef struct
  {
    long int quot;		 
    long int rem;		 
  } ldiv_t;



//#65 "/usr/include/stdlib.h" 3



 



 





 

extern size_t __ctype_get_mb_cur_max  (void)    ;


 
extern double atof  (__const char *__nptr)    ;
 
extern int atoi  (__const char *__nptr)    ;
 
extern long int atol  (__const char *__nptr)    ;


 
__extension__ extern long long int atoll  (__const char *__nptr)    ;


 
extern double strtod  (__const char *__restrict __nptr,
			   char **__restrict __endptr)    ;










 
extern long int strtol  (__const char *__restrict __nptr,
			     char **__restrict __endptr, int __base)    ;
 
extern unsigned long int strtoul  (__const char *__restrict __nptr,
				       char **__restrict __endptr,
				       int __base)    ;


 
__extension__
extern long long int strtoq  (__const char *__restrict __nptr,
				  char **__restrict __endptr, int __base)    ;
 
__extension__
extern unsigned long long int strtouq  (__const char *__restrict __nptr,
					    char **__restrict __endptr,
					    int __base)    ;



 

 
__extension__
extern long long int strtoll  (__const char *__restrict __nptr,
				   char **__restrict __endptr, int __base)    ;
 
__extension__
extern unsigned long long int strtoull  (__const char *__restrict __nptr,
					     char **__restrict __endptr,
					     int __base)    ;



//#190 "/usr/include/stdlib.h" 3



 


extern double __strtod_internal  (__const char *__restrict __nptr,
				      char **__restrict __endptr,
				      int __group)    ;
extern float __strtof_internal  (__const char *__restrict __nptr,
				     char **__restrict __endptr, int __group)    ;
extern long double  __strtold_internal  (__const char *
						__restrict __nptr,
						char **__restrict __endptr,
						int __group)    ;

extern long int __strtol_internal  (__const char *__restrict __nptr,
					char **__restrict __endptr,
					int __base, int __group)    ;



extern unsigned long int __strtoul_internal  (__const char *
						  __restrict __nptr,
						  char **__restrict __endptr,
						  int __base, int __group)    ;




__extension__
extern long long int __strtoll_internal  (__const char *__restrict __nptr,
					      char **__restrict __endptr,
					      int __base, int __group)    ;



__extension__
extern unsigned long long int __strtoull_internal  (__const char *
							__restrict __nptr,
							char **
							__restrict __endptr,
							int __base,
							int __group)    ;






 

extern __inline double
strtod (__const char *__restrict __nptr, char **__restrict __endptr)  
{
  return __strtod_internal (__nptr, __endptr, 0);
}
extern __inline long int
strtol (__const char *__restrict __nptr, char **__restrict __endptr,
	int __base)  
{
  return __strtol_internal (__nptr, __endptr, __base, 0);
}
extern __inline unsigned long int
strtoul (__const char *__restrict __nptr, char **__restrict __endptr,
	 int __base)  
{
  return __strtoul_internal (__nptr, __endptr, __base, 0);
}

//#271 "/usr/include/stdlib.h" 3



__extension__ extern __inline long long int
strtoq (__const char *__restrict __nptr, char **__restrict __endptr,
	int __base)  
{
  return __strtoll_internal (__nptr, __endptr, __base, 0);
}
__extension__ extern __inline unsigned long long int
strtouq (__const char *__restrict __nptr, char **__restrict __endptr,
	 int __base)  
{
  return __strtoull_internal (__nptr, __endptr, __base, 0);
}



__extension__ extern __inline long long int
strtoll (__const char *__restrict __nptr, char **__restrict __endptr,
	 int __base)  
{
  return __strtoll_internal (__nptr, __endptr, __base, 0);
}
__extension__ extern __inline unsigned long long int
strtoull (__const char * __restrict __nptr, char **__restrict __endptr,
	  int __base)  
{
  return __strtoull_internal (__nptr, __endptr, __base, 0);
}


extern __inline double
atof (__const char *__nptr)  
{
  return strtod (__nptr, (char **) ((void *)0) );
}
extern __inline int
atoi (__const char *__nptr)  
{
  return (int) strtol (__nptr, (char **) ((void *)0) , 10);
}
extern __inline long int
atol (__const char *__nptr)  
{
  return strtol (__nptr, (char **) ((void *)0) , 10);
}


__extension__ extern __inline long long int
atoll (__const char *__nptr)  
{
  return strtoll (__nptr, (char **) ((void *)0) , 10);
}





 


extern char *l64a  (long int __n)    ;

 
extern long int a64l  (__const char *__s)    ;


//#1 "/usr/include/sys/types.h" 1 3
 

















 








 




typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;



typedef __ino_t ino_t;











typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;

















typedef __pid_t pid_t;




typedef __id_t id_t;



typedef __ssize_t ssize_t;




typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;



typedef __key_t key_t;






//#1 "/usr/include/time.h" 1 3
 

















 














//#51 "/usr/include/time.h" 3



//#62 "/usr/include/time.h" 3








 
typedef __time_t time_t;





//#89 "/usr/include/time.h" 3




//#279 "/usr/include/time.h" 3



//#122 "/usr/include/sys/types.h" 2 3



//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


//#188 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3





 




 

//#271 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


//#283 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#125 "/usr/include/sys/types.h" 2 3



 
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


 

//#159 "/usr/include/sys/types.h" 3


 







typedef int int8_t __attribute__ ((__mode__ (  __QI__ ))) ;
typedef int int16_t __attribute__ ((__mode__ (  __HI__ ))) ;
typedef int int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
typedef int int64_t __attribute__ ((__mode__ (  __DI__ ))) ;


typedef unsigned int u_int8_t __attribute__ ((__mode__ (  __QI__ ))) ;
typedef unsigned int u_int16_t __attribute__ ((__mode__ (  __HI__ ))) ;
typedef unsigned int u_int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
typedef unsigned int u_int64_t __attribute__ ((__mode__ (  __DI__ ))) ;

typedef int register_t __attribute__ ((__mode__ (__word__)));


 






 
//#1 "/usr/include/endian.h" 1 3
 






















 









 
//#1 "/usr/include/bits/endian.h" 1 3
 






//#35 "/usr/include/endian.h" 2 3


 













//#191 "/usr/include/sys/types.h" 2 3


 
//#1 "/usr/include/sys/select.h" 1 3
 


















 






 


 
//#1 "/usr/include/bits/select.h" 1 3
 

























//#36 "/usr/include/bits/select.h" 3












//#56 "/usr/include/bits/select.h" 3

//#72 "/usr/include/bits/select.h" 3

//#31 "/usr/include/sys/select.h" 2 3


 
//#1 "/usr/include/bits/sigset.h" 1 3
 





















typedef int __sig_atomic_t;

 


typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int))) ];
  } __sigset_t;




 





//#125 "/usr/include/bits/sigset.h" 3

//#34 "/usr/include/sys/select.h" 2 3


 

//#1 "/usr/include/time.h" 1 3
 

















 














//#51 "/usr/include/time.h" 3



//#62 "/usr/include/time.h" 3



//#73 "/usr/include/time.h" 3








 

struct timespec
  {
    long int tv_sec;		 
    long int tv_nsec;		 
  };





//#279 "/usr/include/time.h" 3



//#38 "/usr/include/sys/select.h" 2 3


 

 



struct timeval;

typedef __fd_mask fd_mask;

 
typedef __fd_set fd_set;

 



 




 






 




extern int __select  (int __nfds, __fd_set *__readfds,
			  __fd_set *__writefds, __fd_set *__exceptfds,
			  struct timeval *__timeout)    ;
extern int select  (int __nfds, __fd_set *__readfds,
			__fd_set *__writefds, __fd_set *__exceptfds,
			struct timeval *__timeout)    ;

//#91 "/usr/include/sys/select.h" 3


 


//#194 "/usr/include/sys/types.h" 2 3


 
//#1 "/usr/include/sys/sysmacros.h" 1 3
 





















 








//#47 "/usr/include/sys/sysmacros.h" 3



//#197 "/usr/include/sys/types.h" 2 3




 

typedef __blkcnt_t blkcnt_t;	  
typedef __fsblkcnt_t fsblkcnt_t;  
typedef __fsfilcnt_t fsfilcnt_t;  












 


//#339 "/usr/include/stdlib.h" 2 3


 



 
extern int32_t random  (void)    ;

 
extern void srandom  (unsigned int __seed)    ;

 



extern void *  initstate  (unsigned int __seed, void *  __statebuf,
			       size_t __statelen)    ;

 

extern void *  setstate  (void *  __statebuf)    ;



 



struct random_data
  {
    int32_t *fptr;		 
    int32_t *rptr;		 
    int32_t *state;		 
    int rand_type;		 
    int rand_deg;		 
    int rand_sep;		 
    int32_t *end_ptr;		 
  };

extern int random_r  (struct random_data *__restrict __buf,
			  int32_t *__restrict __result)    ;

extern int srandom_r  (unsigned int __seed, struct random_data *__buf)    ;

extern int initstate_r  (unsigned int __seed,
			     void *  __restrict __statebuf,
			     size_t __statelen,
			     struct random_data *__restrict __buf)    ;

extern int setstate_r  (void *  __restrict __statebuf,
			    struct random_data *__restrict __buf)    ;




 
extern int rand  (void)    ;
 
extern void srand  (unsigned int __seed)    ;


 
extern int rand_r  (unsigned int *__seed)    ;




 

 
extern double drand48  (void)    ;
extern double erand48  (unsigned short int __xsubi[3])    ;

 
extern long int lrand48  (void)    ;
extern long int nrand48  (unsigned short int __xsubi[3])    ;

 
extern long int mrand48  (void)    ;
extern long int jrand48  (unsigned short int __xsubi[3])    ;

 
extern void srand48  (long int __seedval)    ;
extern unsigned short int *seed48  (unsigned short int __seed16v[3])    ;
extern void lcong48  (unsigned short int __param[7])    ;

 
struct drand48_data
  {
    unsigned short int x[3];	 
    unsigned short int a[3];	 
    unsigned short int c;	 
    unsigned short int old_x[3];  
    int init;			 
  };


 
extern int drand48_r  (struct drand48_data *__restrict __buffer,
			   double *__restrict __result)    ;
extern int erand48_r  (unsigned short int __xsubi[3],
			   struct drand48_data *__restrict __buffer,
			   double *__restrict __result)    ;

 
extern int lrand48_r  (struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)    ;
extern int nrand48_r  (unsigned short int __xsubi[3],
			   struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)    ;

 
extern int mrand48_r  (struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)    ;
extern int jrand48_r  (unsigned short int __xsubi[3],
			   struct drand48_data *__restrict __buffer,
			   long int *__restrict __result)    ;

 
extern int srand48_r  (long int __seedval, struct drand48_data *__buffer)    ;

extern int seed48_r  (unsigned short int __seed16v[3],
			  struct drand48_data *__buffer)    ;

extern int lcong48_r  (unsigned short int __param[7],
			   struct drand48_data *__buffer)    ;







 
extern void *  malloc  (size_t __size)    ;
 
extern void *  calloc  (size_t __nmemb, size_t __size)    ;



 

extern void *  realloc  (void *  __ptr, size_t __size)    ;
 
extern void free  (void *  __ptr)    ;


 
extern void cfree  (void *  __ptr)    ;



//#1 "/usr/include/alloca.h" 1 3
 























//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


//#188 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3





 




 

//#271 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


//#283 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#25 "/usr/include/alloca.h" 2 3


 

 


 
extern void *  alloca  (size_t __size)    ;





 


//#492 "/usr/include/stdlib.h" 2 3




 
extern void *  valloc  (size_t __size)    ;



 
extern void abort  (void)     __attribute__ ((__noreturn__));


 
extern int atexit  (void (*__func) (void))    ;


 

extern int __on_exit  (void (*__func) (int __status, void *  __arg),
			   void *  __arg)    ;
extern int on_exit  (void (*__func) (int __status, void *  __arg),
			 void *  __arg)    ;


 


extern void exit  (int __status)     __attribute__ ((__noreturn__));








 
extern char *getenv  (__const char *__name)    ;

 

extern char *__secure_getenv  (__const char *__name)    ;


 
 

extern int putenv  (char *__string)    ;



 

extern int setenv  (__const char *__name, __const char *__value,
			int __replace)    ;

 
extern void unsetenv  (__const char *__name)    ;



 


extern int clearenv  (void)    ;




 



extern char *mktemp  (char *__template)    ;

 




extern int mkstemp  (char *__template)    ;



 
extern int system  (__const char *__command)    ;










 





extern char *realpath  (__const char *__restrict __name,
			    char *__restrict __resolved)    ;



 


typedef int (*__compar_fn_t)  (__const void * , __const void * )  ;






 

extern void *  bsearch  (__const void *  __key, __const void *  __base,
			       size_t __nmemb, size_t __size,
			       __compar_fn_t __compar)  ;

 

extern void qsort  (void *  __base, size_t __nmemb, size_t __size,
			  __compar_fn_t __compar)  ;


 
extern int abs  (int __x)     __attribute__ ((__const__));
extern long int labs  (long int __x)     __attribute__ ((__const__));






 

 
extern div_t div  (int __numer, int __denom)     __attribute__ ((__const__));
extern ldiv_t ldiv  (long int __numer, long int __denom)    
     __attribute__ ((__const__));








 


 


extern char *ecvt  (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign)    ;

 


extern char *fcvt  (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign)    ;

 


extern char *gcvt  (double __value, int __ndigit, char *__buf)    ;

 
extern char *qecvt  (long double  __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign)    ;
extern char *qfcvt  (long double  __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign)    ;
extern char *qgcvt  (long double  __value, int __ndigit, char *__buf)    ;



 

extern int ecvt_r  (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign, char *__restrict __buf,
			size_t __len)    ;
extern int fcvt_r  (double __value, int __ndigit, int *__restrict __decpt,
			int *__restrict __sign, char *__restrict __buf,
			size_t __len)    ;

extern int qecvt_r  (long double  __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign,
			 char *__restrict __buf, size_t __len)    ;
extern int qfcvt_r  (long double  __value, int __ndigit,
			 int *__restrict __decpt, int *__restrict __sign,
			 char *__restrict __buf, size_t __len)    ;




 

extern int mblen  (__const char *__s, size_t __n)    ;
 

extern int mbtowc  (wchar_t *__restrict __pwc,
			__const char *__restrict __s, size_t __n)    ;
 

extern int wctomb  (char *__s, wchar_t __wchar)    ;


 
extern size_t mbstowcs  (wchar_t *__restrict  __pwcs,
			     __const char *__restrict __s, size_t __n)    ;
 
extern size_t wcstombs  (char *__restrict __s,
			     __const wchar_t *__restrict __pwcs, size_t __n)    ;



 



extern int rpmatch  (__const char *__response)    ;



//#732 "/usr/include/stdlib.h" 3



//#756 "/usr/include/stdlib.h" 3


//#766 "/usr/include/stdlib.h" 3





 


//#94 "SDL_RLEaccel.c" 2

//#1 "/usr/include/string.h" 1 3
 

















 








 

 


//#1 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 1 3






 


//#19 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3



 


 





 


//#61 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 





 


















 





 

 

//#131 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 


//#188 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3





 




 

//#271 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


//#283 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3


 

 

//#317 "/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/stddef.h" 3




 





















//#33 "/usr/include/string.h" 2 3



 
extern void *  memcpy  (void *  __restrict __dest,
			    __const void *  __restrict __src, size_t __n)    ;
 

extern void *  memmove  (void *  __dest, __const void *  __src,
			     size_t __n)    ;

 



extern void *  memccpy  (void *  __dest, __const void *  __src,
			     int __c, size_t __n)    ;



 
extern void *  memset  (void *  __s, int __c, size_t __n)    ;

 
extern int memcmp  (__const void *  __s1, __const void *  __s2,
			size_t __n)    ;

 
extern void *  memchr  (__const void *  __s, int __c, size_t __n)    ;








 
extern char *strcpy  (char *__restrict __dest,
			  __const char *__restrict __src)    ;
 
extern char *strncpy  (char *__restrict __dest,
			   __const char *__restrict __src, size_t __n)    ;

 
extern char *strcat  (char *__restrict __dest,
			  __const char *__restrict __src)    ;
 
extern char *strncat  (char *__restrict __dest,
			   __const char *__restrict __src, size_t __n)    ;

 
extern int strcmp  (__const char *__s1, __const char *__s2)    ;
 
extern int strncmp  (__const char *__s1, __const char *__s2, size_t __n)    ;

 
extern int strcoll  (__const char *__s1, __const char *__s2)    ;
 
extern size_t strxfrm  (char *__restrict __dest,
			    __const char *__restrict __src, size_t __n)    ;

//#107 "/usr/include/string.h" 3



 
extern char *__strdup  (__const char *__s)    ;
extern char *strdup  (__const char *__s)    ;


 






//#143 "/usr/include/string.h" 3


 
extern char *strchr  (__const char *__s, int __c)    ;
 
extern char *strrchr  (__const char *__s, int __c)    ;







 

extern size_t strcspn  (__const char *__s, __const char *__reject)    ;
 

extern size_t strspn  (__const char *__s, __const char *__accept)    ;
 
extern char *strpbrk  (__const char *__s, __const char *__accept)    ;
 
extern char *strstr  (__const char *__haystack, __const char *__needle)    ;









 
extern char *strtok  (char *__restrict __s,
			  __const char *__restrict __delim)    ;

 

extern char *__strtok_r  (char *__restrict __s,
			      __const char *__restrict __delim,
			      char **__restrict __save_ptr)    ;

extern char *strtok_r  (char *__restrict __s,
			    __const char *__restrict __delim,
			    char **__restrict __save_ptr)    ;


//#203 "/usr/include/string.h" 3



 
extern size_t strlen  (__const char *__s)    ;








 
extern char *strerror  (int __errnum)    ;

 

extern char *__strerror_r  (int __errnum, char *__buf, size_t __buflen)    ;
extern char *strerror_r  (int __errnum, char *__buf, size_t __buflen)    ;


 

extern void __bzero  (void *  __s, size_t __n)    ;


 
extern void bcopy  (__const void *  __src, void *  __dest, size_t __n)    ;

 
extern void bzero  (void *  __s, size_t __n)    ;

 
extern int bcmp  (__const void *  __s1, __const void *  __s2, size_t __n)    ;

 
extern char *index  (__const char *__s, int __c)    ;

 
extern char *rindex  (__const char *__s, int __c)    ;

 

extern int __ffs  (int __i)     __attribute__ ((const));
extern int ffs  (int __i)     __attribute__ ((const));

 









 
extern int __strcasecmp  (__const char *__s1, __const char *__s2)    ;
extern int strcasecmp  (__const char *__s1, __const char *__s2)    ;

 
extern int strncasecmp  (__const char *__s1, __const char *__s2,
			     size_t __n)    ;


//#277 "/usr/include/string.h" 3



 

extern char *strsep  (char **__restrict __stringp,
			  __const char *__restrict __delim)    ;


//#319 "/usr/include/string.h" 3





 

















 
//#1 "/usr/include/bits/string.h" 1 3
 






















 



 

//#876 "/usr/include/bits/string.h" 3

//#343 "/usr/include/string.h" 2 3


 
//#1 "/usr/include/bits/string2.h" 1 3
 

























 























 












//#73 "/usr/include/bits/string2.h" 3

//#88 "/usr/include/bits/string2.h" 3


 





 















//#180 "/usr/include/bits/string2.h" 3







 









 

//#367 "/usr/include/bits/string2.h" 3



 

extern void *  __rawmemchr (const void *  __s, int __c);







 















extern __inline  char *__strcpy_small (char *, __uint16_t, __uint16_t,
				      __uint32_t, __uint32_t, size_t);
extern __inline  char *
__strcpy_small (char *__dest,
		__uint16_t __src0_2, __uint16_t __src4_2,
		__uint32_t __src0_4, __uint32_t __src4_4,
		size_t __srclen)
{
  union {
    __uint32_t __ui;
    __uint16_t __usi;
    unsigned char __uc;
  } *__u = (void *) __dest;
  switch ((unsigned int) __srclen)
    {
    case 1:
      __u->__uc = '\0';
      break;
    case 2:
      __u->__usi = __src0_2;
      break;
    case 3:
      __u->__usi = __src0_2;
      __u = __extension__ ((void *) __u + 2);
      __u->__uc = '\0';
      break;
    case 4:
      __u->__ui = __src0_4;
      break;
    case 5:
      __u->__ui = __src0_4;
      __u = __extension__ ((void *) __u + 4);
      __u->__uc = '\0';
      break;
    case 6:
      __u->__ui = __src0_4;
      __u = __extension__ ((void *) __u + 4);
      __u->__usi = __src4_2;
      break;
    case 7:
      __u->__ui = __src0_4;
      __u = __extension__ ((void *) __u + 4);
      __u->__usi = __src4_2;
      __u = __extension__ ((void *) __u + 2);
      __u->__uc = '\0';
      break;
    case 8:
      __u->__ui = __src0_4;
      __u = __extension__ ((void *) __u + 4);
      __u->__ui = __src4_4;
      break;
    }
  return __dest;
}
//#531 "/usr/include/bits/string2.h" 3




 
//#697 "/usr/include/bits/string2.h" 3



 

//#712 "/usr/include/bits/string2.h" 3











 

//#733 "/usr/include/bits/string2.h" 3











 


//#766 "/usr/include/bits/string2.h" 3


//#793 "/usr/include/bits/string2.h" 3


//#815 "/usr/include/bits/string2.h" 3


//#840 "/usr/include/bits/string2.h" 3



 











 



//#872 "/usr/include/bits/string2.h" 3

extern __inline  size_t __strcspn_c1 (__const char *__s, char __reject);
extern __inline  size_t
__strcspn_c1 (__const char *__s, char __reject)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline  size_t __strcspn_c2 (__const char *__s, char __reject1,
				     char __reject2);
extern __inline  size_t
__strcspn_c2 (__const char *__s, char __reject1, char __reject2)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
	 && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline  size_t __strcspn_c3 (__const char *__s, char __reject1,
				     char __reject2, char __reject3);
extern __inline  size_t
__strcspn_c3 (__const char *__s, char __reject1, char __reject2,
	      char __reject3)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
	 && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}



 



//#927 "/usr/include/bits/string2.h" 3

extern __inline  size_t __strspn_c1 (__const char *__s, char __accept);
extern __inline  size_t
__strspn_c1 (__const char *__s, char __accept)
{
  register size_t __result = 0;
   
  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline  size_t __strspn_c2 (__const char *__s, char __accept1,
				    char __accept2);
extern __inline  size_t
__strspn_c2 (__const char *__s, char __accept1, char __accept2)
{
  register size_t __result = 0;
   
  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline  size_t __strspn_c3 (__const char *__s, char __accept1,
				    char __accept2, char __accept3);
extern __inline  size_t
__strspn_c3 (__const char *__s, char __accept1, char __accept2, char __accept3)
{
  register size_t __result = 0;
   
  while (__s[__result] == __accept1 || __s[__result] == __accept2
	 || __s[__result] == __accept3)
    ++__result;
  return __result;
}



 


//#982 "/usr/include/bits/string2.h" 3

extern __inline  char *__strpbrk_c2 (__const char *__s, char __accept1,
				     char __accept2);
extern __inline  char *
__strpbrk_c2 (__const char *__s, char __accept1, char __accept2)
{
   
  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0)  : (char *) (size_t) __s;
}

extern __inline  char *__strpbrk_c3 (__const char *__s, char __accept1,
				     char __accept2, char __accept3);
extern __inline  char *
__strpbrk_c3 (__const char *__s, char __accept1, char __accept2,
	      char __accept3)
{
   
  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
	 && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0)  : (char *) (size_t) __s;
}



 


//#1020 "/usr/include/bits/string2.h" 3



//#1032 "/usr/include/bits/string2.h" 3












extern __inline  char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline  char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0) )
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  if (*__s == '\0')
    __result = ((void *)0) ;
  else
    {
      __result = __s;
      while (*__s != '\0' && *__s != __sep)
	++__s;
      if (*__s == '\0')
	*__nextp = __s;
      else
	{
	  *__s = '\0';
	  *__nextp = __s + 1;
	}
    }
  return __result;
}









//#1093 "/usr/include/bits/string2.h" 3

extern __inline  char *__strsep_1c (char **__s, char __reject);
extern __inline  char *
__strsep_1c (char **__s, char __reject)
{
  register char *__retval = *__s;
  if (__retval == ((void *)0) )
    return *__s = ((void *)0) ;
  if (*__retval == __reject)
    *(*__s)++ = '\0';
  else
    if ((*__s = (__extension__ (__builtin_constant_p (  __reject ) && (  __reject ) == '\0'	? (char *) __rawmemchr ( __retval ,   __reject )	: strchr ( __retval ,   __reject ))) ) != ((void *)0) )
      *(*__s)++ = '\0';
    else
      *__s = ((void *)0) ;
  return __retval;
}

extern __inline  char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline  char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  register char *__retval = *__s;
  if (__retval == ((void *)0) )
    return *__s = ((void *)0) ;
  if (*__retval == __reject1 || *__retval == __reject2)
    *(*__s)++ = '\0';
  else
    {
      register char *__cp = __retval;
      while (*__cp != '\0' && *__cp != __reject1 && *__cp != __reject2)
	++__cp;
      if (*__cp != '\0')
	{
	  *__s = __cp;
	  *(*__s)++ = '\0';
	}
      else
	*__s = ((void *)0) ;
    }
  return __retval;
}

extern __inline  char *__strsep_3c (char **__s, char __reject1, char __reject2,
				   char __reject3);
extern __inline  char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  register char *__retval = *__s;
  if (__retval == ((void *)0) )
    return *__s = ((void *)0) ;
  if (*__retval == __reject1 || *__retval == __reject2
      || *__retval == __reject3)
    *(*__s)++ = '\0';
  else
    {
      register char *__cp = __retval;
      while (*__cp != '\0' && *__cp != __reject1 && *__cp != __reject2
	     && *__cp != __reject3)
	++__cp;
      if (*__cp != '\0')
	{
	  *__s = __cp;
	  *(*__s)++ = '\0';
	}
      else
	*__s = ((void *)0) ;
    }
  return __retval;
}

extern __inline  char *__strsep_g (char **__s, __const char *__reject);
extern __inline  char *
__strsep_g (char **__s, __const char *__reject)
{
  register char *__retval = *__s;
  if (__retval == ((void *)0) )
    return ((void *)0) ;
  if ((*__s = __extension__	({ char __a0, __a1, __a2;	(__builtin_constant_p (  __reject ) && ((size_t)(const void *)((   __reject  ) + 1) - (size_t)(const void *)(   __reject  ) == 1) 	? ((__a0 = ((__const char  *) (  __reject ))[0], __a0 == '\0')	? ((void *)0) 	: ((__a1 = ((__const char *) (  __reject ))[1], __a1 == '\0')	? (__extension__ (__builtin_constant_p (  __a0 ) && (  __a0 ) == '\0'	? (char *) __rawmemchr (  __retval  ,   __a0 )	: strchr (  __retval  ,   __a0 ))) 	: ((__a2 = ((__const char *) (  __reject ))[2], __a2 == '\0')	? __strpbrk_c2 ( __retval , __a0, __a1)	: (((__const char *) (  __reject ))[3] == '\0'	? __strpbrk_c3 ( __retval , __a0, __a1, __a2)	: strpbrk ( __retval ,   __reject )))))	: strpbrk ( __retval ,   __reject )); }) ) != ((void *)0) )
    *(*__s)++ = '\0';
  return __retval;
}





 












//#1202 "/usr/include/bits/string2.h" 3













//#346 "/usr/include/string.h" 2 3




 


//#95 "SDL_RLEaccel.c" 2


//#1 "../../include/SDL_types.h" 1
 


























 




 


 
typedef enum {
	SDL_FALSE = 0,
	SDL_TRUE  = 1
} SDL_bool;
typedef unsigned char	Uint8;
typedef signed char	Sint8;
typedef unsigned short	Uint16;
typedef signed short	Sint16;
typedef unsigned int	Uint32;
typedef signed int	Sint32;

 








 




 


typedef unsigned long long  Uint64;

typedef long long  Sint64;








 



typedef int SDL_dummy_uint8 [(  sizeof(Uint8) == 1 ) * 2 - 1] ;
typedef int SDL_dummy_sint8 [(  sizeof(Sint8) == 1 ) * 2 - 1] ;
typedef int SDL_dummy_uint16 [(  sizeof(Uint16) == 2 ) * 2 - 1] ;
typedef int SDL_dummy_sint16 [(  sizeof(Sint16) == 2 ) * 2 - 1] ;
typedef int SDL_dummy_uint32 [(  sizeof(Uint32) == 4 ) * 2 - 1] ;
typedef int SDL_dummy_sint32 [(  sizeof(Sint32) == 4 ) * 2 - 1] ;
typedef int SDL_dummy_uint64 [(  sizeof(Uint64) == 8 ) * 2 - 1] ;
typedef int SDL_dummy_sint64 [(  sizeof(Sint64) == 8 ) * 2 - 1] ;

 




 




typedef enum {
	DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

typedef int SDL_dummy_enum [(  sizeof(SDL_DUMMY_ENUM) == sizeof(int) ) * 2 - 1] ;



 
enum { SDL_PRESSED = 0x01, SDL_RELEASED = 0x00 };


//#97 "SDL_RLEaccel.c" 2

//#1 "../../include/SDL_video.h" 1
 


























 






//#1 "../../include/SDL_types.h" 1
 


























 

//#110 "../../include/SDL_types.h"

//#35 "../../include/SDL_video.h" 2

//#1 "../../include/SDL_mutex.h" 1
 





























 




//#1 "../../include/SDL_main.h" 1
 





























 

//#99 "../../include/SDL_main.h"



//#36 "../../include/SDL_mutex.h" 2

//#1 "../../include/SDL_types.h" 1
 


























 

//#110 "../../include/SDL_types.h"

//#37 "../../include/SDL_mutex.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 








//#58 "../../include/begin_code.h"






 








 





 




//#95 "../../include/begin_code.h"


 



//#116 "../../include/begin_code.h"



 







 









//#39 "../../include/SDL_mutex.h" 2

 




 




 



 
 
 

 
struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;

 
extern   SDL_mutex *   SDL_CreateMutex(void);

 

extern   int   SDL_mutexP(SDL_mutex *mutex);

 




extern   int   SDL_mutexV(SDL_mutex *mutex);

 
extern   void   SDL_DestroyMutex(SDL_mutex *mutex);


 
 
 

 
struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;

 
extern   SDL_sem *   SDL_CreateSemaphore(Uint32 initial_value);

 
extern   void   SDL_DestroySemaphore(SDL_sem *sem);

 



extern   int   SDL_SemWait(SDL_sem *sem);

 


extern   int   SDL_SemTryWait(SDL_sem *sem);

 





extern   int   SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms);

 


extern   int   SDL_SemPost(SDL_sem *sem);

 
extern   Uint32   SDL_SemValue(SDL_sem *sem);


 
 
 

 
struct SDL_cond;
typedef struct SDL_cond SDL_cond;

 
extern   SDL_cond *   SDL_CreateCond(void);

 
extern   void   SDL_DestroyCond(SDL_cond *cond);

 


extern   int   SDL_CondSignal(SDL_cond *cond);

 


extern   int   SDL_CondBroadcast(SDL_cond *cond);

 



extern   int   SDL_CondWait(SDL_cond *cond, SDL_mutex *mut);

 





extern   int   SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);

 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#164 "../../include/SDL_mutex.h" 2



//#36 "../../include/SDL_video.h" 2

//#1 "../../include/SDL_rwops.h" 1
 


























 








//#1 "../../include/SDL_types.h" 1
 


























 

//#110 "../../include/SDL_types.h"

//#37 "../../include/SDL_rwops.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#39 "../../include/SDL_rwops.h" 2

 




 

typedef struct SDL_RWops {
	 



	int (*seek)(struct SDL_RWops *context, int offset, int whence);

	 



	int (*read)(struct SDL_RWops *context, void *ptr, int size, int maxnum);

	 



	int (*write)(struct SDL_RWops *context, const void *ptr, int size, int num);

	 
	int (*close)(struct SDL_RWops *context);

	Uint32 type;
	union {
	    struct {
		int autoclose;
	 	FILE *fp;
	    } stdio;
	    struct {
		Uint8 *base;
	 	Uint8 *here;
		Uint8 *stop;
	    } mem;
	    struct {
		void *data1;
	    } unknown;
	} hidden;

} SDL_RWops;


 

extern   SDL_RWops *   SDL_RWFromFile(const char *file, const char *mode);

extern   SDL_RWops *   SDL_RWFromFP(FILE *fp, int autoclose);

extern   SDL_RWops *   SDL_RWFromMem(void *mem, int size);

extern   SDL_RWops *   SDL_AllocRW(void);
extern   void   SDL_FreeRW(SDL_RWops *area);

 







 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#111 "../../include/SDL_rwops.h" 2



//#37 "../../include/SDL_video.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#39 "../../include/SDL_video.h" 2

 




 



 
typedef struct {
	Sint16 x, y;
	Uint16 w, h;
} SDL_Rect;

typedef struct {
	Uint8 r;
	Uint8 g;
	Uint8 b;
	Uint8 unused;
} SDL_Color;


typedef struct {
	int       ncolors;
	SDL_Color *colors;
} SDL_Palette;

 
typedef struct SDL_PixelFormat {
	SDL_Palette *palette;
	Uint8  BitsPerPixel;
	Uint8  BytesPerPixel;
	Uint8  Rloss;
	Uint8  Gloss;
	Uint8  Bloss;
	Uint8  Aloss;
	Uint8  Rshift;
	Uint8  Gshift;
	Uint8  Bshift;
	Uint8  Ashift;
	Uint32 Rmask;
	Uint32 Gmask;
	Uint32 Bmask;
	Uint32 Amask;

	 
	Uint32 colorkey;
	 
	Uint8  alpha;
} SDL_PixelFormat;

 
struct SDL_Surface;
typedef int (*SDL_blit)(struct SDL_Surface *src, SDL_Rect *srcrect,
			struct SDL_Surface *dst, SDL_Rect *dstrect);

 


typedef struct SDL_Surface {
	Uint32 flags;				 
	SDL_PixelFormat *format;		 
	int w, h;				 
	Uint16 pitch;				 
	void *pixels;				 
	int offset;				 

	 
	struct private_hwdata *hwdata;

	 
	SDL_Rect clip_rect;			 
	Uint32 unused1;				 

	 
	Uint32 locked;				 

	 
	struct SDL_BlitMap *map;		 

	 
	unsigned int format_version;		 

	 
	int refcount;				 
} SDL_Surface;

 
 



 








 







 





 
typedef struct {
	Uint32 hw_available :1;	 
	Uint32 wm_available :1;	 
	Uint32 UnusedBits1  :6;
	Uint32 UnusedBits2  :1;
	Uint32 blit_hw      :1;	 
	Uint32 blit_hw_CC   :1;	 
	Uint32 blit_hw_A    :1;	 
	Uint32 blit_sw      :1;	 
	Uint32 blit_sw_CC   :1;	 
	Uint32 blit_sw_A    :1;	 
	Uint32 blit_fill    :1;	 
	Uint32 UnusedBits3  :16;
	Uint32 video_mem;	 
	SDL_PixelFormat *vfmt;	 
} SDL_VideoInfo;


 












 
typedef struct SDL_Overlay {
	Uint32 format;				 
	int w, h;				 
	int planes;				 
	Uint16 *pitches;			 
	Uint8 **pixels;				 

	 
	struct private_yuvhwfuncs *hwfuncs;
	struct private_yuvhwdata *hwdata;

	 
	Uint32 hw_overlay :1;	 
	Uint32 UnusedBits :31;
} SDL_Overlay;


 
typedef enum {
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES
} SDL_GLattr;

 



 

 












extern   int   SDL_VideoInit(const char *driver_name, Uint32 flags);
extern   void   SDL_VideoQuit(void);

 



extern   char *   SDL_VideoDriverName(char *namebuf, int maxlen);

 





extern   SDL_Surface *   SDL_GetVideoSurface(void);

 





extern   const SDL_VideoInfo *   SDL_GetVideoInfo(void);

 










extern   int   SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);

 








extern   SDL_Rect **   SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);

 

























































extern   SDL_Surface *   SDL_SetVideoMode
			(int width, int height, int bpp, Uint32 flags);

 





extern   void   SDL_UpdateRects
		(SDL_Surface *screen, int numrects, SDL_Rect *rects);
extern   void   SDL_UpdateRect
		(SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h);

 









extern   int   SDL_Flip(SDL_Surface *screen);

 







extern   int   SDL_SetGamma(float red, float green, float blue);

 











extern   int   SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue);

 








extern   int   SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue);

 














extern   int   SDL_SetColors(SDL_Surface *surface, 
			SDL_Color *colors, int firstcolor, int ncolors);

 















extern   int   SDL_SetPalette(SDL_Surface *surface, int flags,
				   SDL_Color *colors, int firstcolor,
				   int ncolors);

 


extern   Uint32   SDL_MapRGB
			(SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b);

 


extern   Uint32   SDL_MapRGBA(SDL_PixelFormat *format,
				   Uint8 r, Uint8 g, Uint8 b, Uint8 a);

 


extern   void   SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt,
				Uint8 *r, Uint8 *g, Uint8 *b);

 


extern   void   SDL_GetRGBA(Uint32 pixel, SDL_PixelFormat *fmt,
				 Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);

 


































extern   SDL_Surface *   SDL_CreateRGBSurface
			(Uint32 flags, int width, int height, int depth, 
			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern   SDL_Surface *   SDL_CreateRGBSurfaceFrom(void *pixels,
			int width, int height, int depth, int pitch,
			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern   void   SDL_FreeSurface(SDL_Surface *surface);

 

















extern   int   SDL_LockSurface(SDL_Surface *surface);
extern   void   SDL_UnlockSurface(SDL_Surface *surface);

 





extern   SDL_Surface *   SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);

 


 




extern   int   SDL_SaveBMP_RW
		(SDL_Surface *surface, SDL_RWops *dst, int freedst);

 



 








extern   int   SDL_SetColorKey
			(SDL_Surface *surface, Uint32 flag, Uint32 key);

 














extern   int   SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);

 











extern   SDL_bool   SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect);

 




extern   void   SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect);

 











extern   SDL_Surface *   SDL_ConvertSurface
			(SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags);

 

































































 




 


extern   int   SDL_UpperBlit
			(SDL_Surface *src, SDL_Rect *srcrect,
			 SDL_Surface *dst, SDL_Rect *dstrect);
 


extern   int   SDL_LowerBlit
			(SDL_Surface *src, SDL_Rect *srcrect,
			 SDL_Surface *dst, SDL_Rect *dstrect);

 








extern   int   SDL_FillRect
		(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);

 










extern   SDL_Surface *   SDL_DisplayFormat(SDL_Surface *surface);

 











extern   SDL_Surface *   SDL_DisplayFormatAlpha(SDL_Surface *surface);


 
 
 

 




extern   SDL_Overlay *   SDL_CreateYUVOverlay(int width, int height,
				Uint32 format, SDL_Surface *display);

 
extern   int   SDL_LockYUVOverlay(SDL_Overlay *overlay);
extern   void   SDL_UnlockYUVOverlay(SDL_Overlay *overlay);

 





extern   int   SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect);

 
extern   void   SDL_FreeYUVOverlay(SDL_Overlay *overlay);


 
 
 

 









extern   int   SDL_GL_LoadLibrary(const char *path);

 


extern   void *   SDL_GL_GetProcAddress(const char* proc);

 


extern   int   SDL_GL_SetAttribute(SDL_GLattr attr, int value);

 








extern   int   SDL_GL_GetAttribute(SDL_GLattr attr, int* value);

 


extern   void   SDL_GL_SwapBuffers(void);

 



extern   void   SDL_GL_UpdateRects(int numrects, SDL_Rect* rects);
extern   void   SDL_GL_Lock(void);
extern   void   SDL_GL_Unlock(void);

 
 
 

 


extern   void   SDL_WM_SetCaption(const char *title, const char *icon);
extern   void   SDL_WM_GetCaption(char **title, char **icon);

 





extern   void   SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);

 




extern   int   SDL_WM_IconifyWindow(void);

 














extern   int   SDL_WM_ToggleFullScreen(SDL_Surface *surface);

 



typedef enum {
	SDL_GRAB_QUERY = -1,
	SDL_GRAB_OFF = 0,
	SDL_GRAB_ON = 1,
	SDL_GRAB_FULLSCREEN	 
} SDL_GrabMode;
 




extern   SDL_GrabMode   SDL_WM_GrabInput(SDL_GrabMode mode);

 
extern   int   SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                                    SDL_Surface *dst, SDL_Rect *dstrect);
                    
 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#895 "../../include/SDL_video.h" 2



//#98 "SDL_RLEaccel.c" 2

//#1 "../../include/SDL_error.h" 1
 


























 




//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#33 "../../include/SDL_error.h" 2

 




 
extern   void   SDL_SetError(const char *fmt, ...);
extern   char *   SDL_GetError(void);
extern   void   SDL_ClearError(void);

 

typedef enum {
	SDL_ENOMEM,
	SDL_EFREAD,
	SDL_EFWRITE,
	SDL_EFSEEK,
	SDL_LASTERROR
} SDL_errorcode;
extern void SDL_Error(SDL_errorcode code);


 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#60 "../../include/SDL_error.h" 2



//#99 "SDL_RLEaccel.c" 2

//#1 "SDL_sysvideo.h" 1
 





























//#1 "../../include/SDL_mouse.h" 1
 


























 




//#1 "../../include/SDL_types.h" 1
 


























 

//#110 "../../include/SDL_types.h"

//#33 "../../include/SDL_mouse.h" 2

//#1 "../../include/SDL_video.h" 1
 


























 

//#897 "../../include/SDL_video.h"

//#34 "../../include/SDL_mouse.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#36 "../../include/SDL_mouse.h" 2

 




typedef struct WMcursor WMcursor;	 
typedef struct {
	SDL_Rect area;			 
	Sint16 hot_x, hot_y;		 
	Uint8 *data;			 
	Uint8 *mask;			 
	Uint8 *save[2];			 
	WMcursor *wm_cursor;		 
} SDL_Cursor;

 
 





extern   Uint8   SDL_GetMouseState(int *x, int *y);

 





extern   Uint8   SDL_GetRelativeMouseState(int *x, int *y);

 


extern   void   SDL_WarpMouse(Uint16 x, Uint16 y);

 












extern   SDL_Cursor *   SDL_CreateCursor
		(Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);

 




extern   void   SDL_SetCursor(SDL_Cursor *cursor);

 


extern   SDL_Cursor *   SDL_GetCursor(void);

 


extern   void   SDL_FreeCursor(SDL_Cursor *cursor);

 






extern   int   SDL_ShowCursor(int toggle);

 

















 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#138 "../../include/SDL_mouse.h" 2



//#31 "SDL_sysvideo.h" 2


//#1 "../../include/SDL_syswm.h" 1
 


























 




//#1 "../../include/SDL_version.h" 1
 


























 




//#1 "../../include/SDL_types.h" 1
 


























 

//#110 "../../include/SDL_types.h"

//#33 "../../include/SDL_version.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#35 "../../include/SDL_version.h" 2

 




 





typedef struct {
	Uint8 major;
	Uint8 minor;
	Uint8 patch;
} SDL_version;

 









 






 



 



 



extern   const SDL_version *   SDL_Linked_Version(void);

 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#88 "../../include/SDL_version.h" 2



//#33 "../../include/SDL_syswm.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#35 "../../include/SDL_syswm.h" 2

 




 





struct SDL_SysWMinfo;
typedef struct SDL_SysWMinfo SDL_SysWMinfo;
//#166 "../../include/SDL_syswm.h"


 
 





extern   int   SDL_GetWMInfo(SDL_SysWMinfo *info);


 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#182 "../../include/SDL_syswm.h" 2



//#33 "SDL_sysvideo.h" 2



 



 












//#1 "/usr/X11R6/include/GL/gl.h" 1

 
































 














//#59 "/usr/X11R6/include/GL/gl.h"

 











 
















 







typedef unsigned int	GLenum;
typedef unsigned char	GLboolean;
typedef unsigned int	GLbitfield;
typedef void		GLvoid;
typedef signed char	GLbyte;		 
typedef short		GLshort;	 
typedef int		GLint;		 
typedef unsigned char	GLubyte;	 
typedef unsigned short	GLushort;	 
typedef unsigned int	GLuint;		 
typedef int		GLsizei;	 
typedef float		GLfloat;	 
typedef float		GLclampf;	 
typedef double		GLdouble;	 
typedef double		GLclampd;	 



 





 



 












 











 









































 





 





 








 




















 






 
















 



































 







 











 




 



















 




 

















 



 











 





















 
















 



 
 
 


































 














 




























 



























 









 



 

















































 












































 








 











 


































 





 









 


































 


 
















 























 











 














 









 




































 



extern  void   glClearIndex( GLfloat c );

extern  void   glClearColor( GLclampf red,
			  GLclampf green,
			  GLclampf blue,
			  GLclampf alpha );

extern  void   glClear( GLbitfield mask );

extern  void   glIndexMask( GLuint mask );

extern  void   glColorMask( GLboolean red, GLboolean green,
			 GLboolean blue, GLboolean alpha );

extern  void   glAlphaFunc( GLenum func, GLclampf ref );

extern  void   glBlendFunc( GLenum sfactor, GLenum dfactor );

extern  void   glLogicOp( GLenum opcode );

extern  void   glCullFace( GLenum mode );

extern  void   glFrontFace( GLenum mode );

extern  void   glPointSize( GLfloat size );

extern  void   glLineWidth( GLfloat width );

extern  void   glLineStipple( GLint factor, GLushort pattern );

extern  void   glPolygonMode( GLenum face, GLenum mode );

extern  void   glPolygonOffset( GLfloat factor, GLfloat units );

extern  void   glPolygonStipple( const GLubyte *mask );

extern  void   glGetPolygonStipple( GLubyte *mask );

extern  void   glEdgeFlag( GLboolean flag );

extern  void   glEdgeFlagv( const GLboolean *flag );

extern  void   glScissor( GLint x, GLint y,
                                   GLsizei width, GLsizei height);

extern  void   glClipPlane( GLenum plane, const GLdouble *equation );

extern  void   glGetClipPlane( GLenum plane, GLdouble *equation );

extern  void   glDrawBuffer( GLenum mode );

extern  void   glReadBuffer( GLenum mode );

extern  void   glEnable( GLenum cap );

extern  void   glDisable( GLenum cap );

extern  GLboolean   glIsEnabled( GLenum cap );


extern  void   glEnableClientState( GLenum cap );   

extern  void   glDisableClientState( GLenum cap );   


extern  void   glGetBooleanv( GLenum pname, GLboolean *params );

extern  void   glGetDoublev( GLenum pname, GLdouble *params );

extern  void   glGetFloatv( GLenum pname, GLfloat *params );

extern  void   glGetIntegerv( GLenum pname, GLint *params );


extern  void   glPushAttrib( GLbitfield mask );

extern  void   glPopAttrib( void );


extern  void   glPushClientAttrib( GLbitfield mask );   

extern  void   glPopClientAttrib( void );   


extern  GLint   glRenderMode( GLenum mode );

extern  GLenum   glGetError( void );

extern  const GLubyte*   glGetString( GLenum name );

extern  void   glFinish( void );

extern  void   glFlush( void );

extern  void   glHint( GLenum target, GLenum mode );



 



extern  void   glClearDepth( GLclampd depth );

extern  void   glDepthFunc( GLenum func );

extern  void   glDepthMask( GLboolean flag );

extern  void   glDepthRange( GLclampd near_val, GLclampd far_val );


 



extern  void   glClearAccum( GLfloat red, GLfloat green,
                                      GLfloat blue, GLfloat alpha );

extern  void   glAccum( GLenum op, GLfloat value );



 



extern  void   glMatrixMode( GLenum mode );

extern  void   glOrtho( GLdouble left, GLdouble right,
                                 GLdouble bottom, GLdouble top,
                                 GLdouble near_val, GLdouble far_val );

extern  void   glFrustum( GLdouble left, GLdouble right,
                                   GLdouble bottom, GLdouble top,
                                   GLdouble near_val, GLdouble far_val );

extern  void   glViewport( GLint x, GLint y,
                                    GLsizei width, GLsizei height );

extern  void   glPushMatrix( void );

extern  void   glPopMatrix( void );

extern  void   glLoadIdentity( void );

extern  void   glLoadMatrixd( const GLdouble *m );
extern  void   glLoadMatrixf( const GLfloat *m );

extern  void   glMultMatrixd( const GLdouble *m );
extern  void   glMultMatrixf( const GLfloat *m );

extern  void   glRotated( GLdouble angle,
                                   GLdouble x, GLdouble y, GLdouble z );
extern  void   glRotatef( GLfloat angle,
                                   GLfloat x, GLfloat y, GLfloat z );

extern  void   glScaled( GLdouble x, GLdouble y, GLdouble z );
extern  void   glScalef( GLfloat x, GLfloat y, GLfloat z );

extern  void   glTranslated( GLdouble x, GLdouble y, GLdouble z );
extern  void   glTranslatef( GLfloat x, GLfloat y, GLfloat z );



 



extern  GLboolean   glIsList( GLuint list );

extern  void   glDeleteLists( GLuint list, GLsizei range );

extern  GLuint   glGenLists( GLsizei range );

extern  void   glNewList( GLuint list, GLenum mode );

extern  void   glEndList( void );

extern  void   glCallList( GLuint list );

extern  void   glCallLists( GLsizei n, GLenum type,
                                     const GLvoid *lists );

extern  void   glListBase( GLuint base );



 



extern  void   glBegin( GLenum mode );

extern  void   glEnd( void );


extern  void   glVertex2d( GLdouble x, GLdouble y );
extern  void   glVertex2f( GLfloat x, GLfloat y );
extern  void   glVertex2i( GLint x, GLint y );
extern  void   glVertex2s( GLshort x, GLshort y );

extern  void   glVertex3d( GLdouble x, GLdouble y, GLdouble z );
extern  void   glVertex3f( GLfloat x, GLfloat y, GLfloat z );
extern  void   glVertex3i( GLint x, GLint y, GLint z );
extern  void   glVertex3s( GLshort x, GLshort y, GLshort z );

extern  void   glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
extern  void   glVertex4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
extern  void   glVertex4i( GLint x, GLint y, GLint z, GLint w );
extern  void   glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w );

extern  void   glVertex2dv( const GLdouble *v );
extern  void   glVertex2fv( const GLfloat *v );
extern  void   glVertex2iv( const GLint *v );
extern  void   glVertex2sv( const GLshort *v );

extern  void   glVertex3dv( const GLdouble *v );
extern  void   glVertex3fv( const GLfloat *v );
extern  void   glVertex3iv( const GLint *v );
extern  void   glVertex3sv( const GLshort *v );

extern  void   glVertex4dv( const GLdouble *v );
extern  void   glVertex4fv( const GLfloat *v );
extern  void   glVertex4iv( const GLint *v );
extern  void   glVertex4sv( const GLshort *v );


extern  void   glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz );
extern  void   glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz );
extern  void   glNormal3f( GLfloat nx, GLfloat ny, GLfloat nz );
extern  void   glNormal3i( GLint nx, GLint ny, GLint nz );
extern  void   glNormal3s( GLshort nx, GLshort ny, GLshort nz );

extern  void   glNormal3bv( const GLbyte *v );
extern  void   glNormal3dv( const GLdouble *v );
extern  void   glNormal3fv( const GLfloat *v );
extern  void   glNormal3iv( const GLint *v );
extern  void   glNormal3sv( const GLshort *v );


extern  void   glIndexd( GLdouble c );
extern  void   glIndexf( GLfloat c );
extern  void   glIndexi( GLint c );
extern  void   glIndexs( GLshort c );
extern  void   glIndexub( GLubyte c );   

extern  void   glIndexdv( const GLdouble *c );
extern  void   glIndexfv( const GLfloat *c );
extern  void   glIndexiv( const GLint *c );
extern  void   glIndexsv( const GLshort *c );
extern  void   glIndexubv( const GLubyte *c );   

extern  void   glColor3b( GLbyte red, GLbyte green, GLbyte blue );
extern  void   glColor3d( GLdouble red, GLdouble green, GLdouble blue );
extern  void   glColor3f( GLfloat red, GLfloat green, GLfloat blue );
extern  void   glColor3i( GLint red, GLint green, GLint blue );
extern  void   glColor3s( GLshort red, GLshort green, GLshort blue );
extern  void   glColor3ub( GLubyte red, GLubyte green, GLubyte blue );
extern  void   glColor3ui( GLuint red, GLuint green, GLuint blue );
extern  void   glColor3us( GLushort red, GLushort green, GLushort blue );

extern  void   glColor4b( GLbyte red, GLbyte green,
                                   GLbyte blue, GLbyte alpha );
extern  void   glColor4d( GLdouble red, GLdouble green,
                                   GLdouble blue, GLdouble alpha );
extern  void   glColor4f( GLfloat red, GLfloat green,
                                   GLfloat blue, GLfloat alpha );
extern  void   glColor4i( GLint red, GLint green,
                                   GLint blue, GLint alpha );
extern  void   glColor4s( GLshort red, GLshort green,
                                   GLshort blue, GLshort alpha );
extern  void   glColor4ub( GLubyte red, GLubyte green,
                                    GLubyte blue, GLubyte alpha );
extern  void   glColor4ui( GLuint red, GLuint green,
                                    GLuint blue, GLuint alpha );
extern  void   glColor4us( GLushort red, GLushort green,
                                    GLushort blue, GLushort alpha );


extern  void   glColor3bv( const GLbyte *v );
extern  void   glColor3dv( const GLdouble *v );
extern  void   glColor3fv( const GLfloat *v );
extern  void   glColor3iv( const GLint *v );
extern  void   glColor3sv( const GLshort *v );
extern  void   glColor3ubv( const GLubyte *v );
extern  void   glColor3uiv( const GLuint *v );
extern  void   glColor3usv( const GLushort *v );

extern  void   glColor4bv( const GLbyte *v );
extern  void   glColor4dv( const GLdouble *v );
extern  void   glColor4fv( const GLfloat *v );
extern  void   glColor4iv( const GLint *v );
extern  void   glColor4sv( const GLshort *v );
extern  void   glColor4ubv( const GLubyte *v );
extern  void   glColor4uiv( const GLuint *v );
extern  void   glColor4usv( const GLushort *v );


extern  void   glTexCoord1d( GLdouble s );
extern  void   glTexCoord1f( GLfloat s );
extern  void   glTexCoord1i( GLint s );
extern  void   glTexCoord1s( GLshort s );

extern  void   glTexCoord2d( GLdouble s, GLdouble t );
extern  void   glTexCoord2f( GLfloat s, GLfloat t );
extern  void   glTexCoord2i( GLint s, GLint t );
extern  void   glTexCoord2s( GLshort s, GLshort t );

extern  void   glTexCoord3d( GLdouble s, GLdouble t, GLdouble r );
extern  void   glTexCoord3f( GLfloat s, GLfloat t, GLfloat r );
extern  void   glTexCoord3i( GLint s, GLint t, GLint r );
extern  void   glTexCoord3s( GLshort s, GLshort t, GLshort r );

extern  void   glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
extern  void   glTexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
extern  void   glTexCoord4i( GLint s, GLint t, GLint r, GLint q );
extern  void   glTexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q );

extern  void   glTexCoord1dv( const GLdouble *v );
extern  void   glTexCoord1fv( const GLfloat *v );
extern  void   glTexCoord1iv( const GLint *v );
extern  void   glTexCoord1sv( const GLshort *v );

extern  void   glTexCoord2dv( const GLdouble *v );
extern  void   glTexCoord2fv( const GLfloat *v );
extern  void   glTexCoord2iv( const GLint *v );
extern  void   glTexCoord2sv( const GLshort *v );

extern  void   glTexCoord3dv( const GLdouble *v );
extern  void   glTexCoord3fv( const GLfloat *v );
extern  void   glTexCoord3iv( const GLint *v );
extern  void   glTexCoord3sv( const GLshort *v );

extern  void   glTexCoord4dv( const GLdouble *v );
extern  void   glTexCoord4fv( const GLfloat *v );
extern  void   glTexCoord4iv( const GLint *v );
extern  void   glTexCoord4sv( const GLshort *v );


extern  void   glRasterPos2d( GLdouble x, GLdouble y );
extern  void   glRasterPos2f( GLfloat x, GLfloat y );
extern  void   glRasterPos2i( GLint x, GLint y );
extern  void   glRasterPos2s( GLshort x, GLshort y );

extern  void   glRasterPos3d( GLdouble x, GLdouble y, GLdouble z );
extern  void   glRasterPos3f( GLfloat x, GLfloat y, GLfloat z );
extern  void   glRasterPos3i( GLint x, GLint y, GLint z );
extern  void   glRasterPos3s( GLshort x, GLshort y, GLshort z );

extern  void   glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
extern  void   glRasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
extern  void   glRasterPos4i( GLint x, GLint y, GLint z, GLint w );
extern  void   glRasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w );

extern  void   glRasterPos2dv( const GLdouble *v );
extern  void   glRasterPos2fv( const GLfloat *v );
extern  void   glRasterPos2iv( const GLint *v );
extern  void   glRasterPos2sv( const GLshort *v );

extern  void   glRasterPos3dv( const GLdouble *v );
extern  void   glRasterPos3fv( const GLfloat *v );
extern  void   glRasterPos3iv( const GLint *v );
extern  void   glRasterPos3sv( const GLshort *v );

extern  void   glRasterPos4dv( const GLdouble *v );
extern  void   glRasterPos4fv( const GLfloat *v );
extern  void   glRasterPos4iv( const GLint *v );
extern  void   glRasterPos4sv( const GLshort *v );


extern  void   glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
extern  void   glRectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
extern  void   glRecti( GLint x1, GLint y1, GLint x2, GLint y2 );
extern  void   glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );


extern  void   glRectdv( const GLdouble *v1, const GLdouble *v2 );
extern  void   glRectfv( const GLfloat *v1, const GLfloat *v2 );
extern  void   glRectiv( const GLint *v1, const GLint *v2 );
extern  void   glRectsv( const GLshort *v1, const GLshort *v2 );



 



extern  void   glVertexPointer( GLint size, GLenum type,
                                       GLsizei stride, const GLvoid *ptr );

extern  void   glNormalPointer( GLenum type, GLsizei stride,
                                       const GLvoid *ptr );

extern  void   glColorPointer( GLint size, GLenum type,
                                      GLsizei stride, const GLvoid *ptr );

extern  void   glIndexPointer( GLenum type, GLsizei stride,
                                      const GLvoid *ptr );

extern  void   glTexCoordPointer( GLint size, GLenum type,
                                         GLsizei stride, const GLvoid *ptr );

extern  void   glEdgeFlagPointer( GLsizei stride, const GLvoid *ptr );

extern  void   glGetPointerv( GLenum pname, void **params );

extern  void   glArrayElement( GLint i );

extern  void   glDrawArrays( GLenum mode, GLint first, GLsizei count );

extern  void   glDrawElements( GLenum mode, GLsizei count,
                                      GLenum type, const GLvoid *indices );

extern  void   glInterleavedArrays( GLenum format, GLsizei stride,
                                           const GLvoid *pointer );


 



extern  void   glShadeModel( GLenum mode );

extern  void   glLightf( GLenum light, GLenum pname, GLfloat param );
extern  void   glLighti( GLenum light, GLenum pname, GLint param );
extern  void   glLightfv( GLenum light, GLenum pname,
                                 const GLfloat *params );
extern  void   glLightiv( GLenum light, GLenum pname,
                                 const GLint *params );

extern  void   glGetLightfv( GLenum light, GLenum pname,
                                    GLfloat *params );
extern  void   glGetLightiv( GLenum light, GLenum pname,
                                    GLint *params );

extern  void   glLightModelf( GLenum pname, GLfloat param );
extern  void   glLightModeli( GLenum pname, GLint param );
extern  void   glLightModelfv( GLenum pname, const GLfloat *params );
extern  void   glLightModeliv( GLenum pname, const GLint *params );

extern  void   glMaterialf( GLenum face, GLenum pname, GLfloat param );
extern  void   glMateriali( GLenum face, GLenum pname, GLint param );
extern  void   glMaterialfv( GLenum face, GLenum pname, const GLfloat *params );
extern  void   glMaterialiv( GLenum face, GLenum pname, const GLint *params );

extern  void   glGetMaterialfv( GLenum face, GLenum pname, GLfloat *params );
extern  void   glGetMaterialiv( GLenum face, GLenum pname, GLint *params );

extern  void   glColorMaterial( GLenum face, GLenum mode );




 



extern  void   glPixelZoom( GLfloat xfactor, GLfloat yfactor );

extern  void   glPixelStoref( GLenum pname, GLfloat param );
extern  void   glPixelStorei( GLenum pname, GLint param );

extern  void   glPixelTransferf( GLenum pname, GLfloat param );
extern  void   glPixelTransferi( GLenum pname, GLint param );

extern  void   glPixelMapfv( GLenum map, GLint mapsize,
                                    const GLfloat *values );
extern  void   glPixelMapuiv( GLenum map, GLint mapsize,
                                     const GLuint *values );
extern  void   glPixelMapusv( GLenum map, GLint mapsize,
                                     const GLushort *values );

extern  void   glGetPixelMapfv( GLenum map, GLfloat *values );
extern  void   glGetPixelMapuiv( GLenum map, GLuint *values );
extern  void   glGetPixelMapusv( GLenum map, GLushort *values );

extern  void   glBitmap( GLsizei width, GLsizei height,
                                GLfloat xorig, GLfloat yorig,
                                GLfloat xmove, GLfloat ymove,
                                const GLubyte *bitmap );

extern  void   glReadPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    GLvoid *pixels );

extern  void   glDrawPixels( GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

extern  void   glCopyPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum type );



 



extern  void   glStencilFunc( GLenum func, GLint ref, GLuint mask );

extern  void   glStencilMask( GLuint mask );

extern  void   glStencilOp( GLenum fail, GLenum zfail, GLenum zpass );

extern  void   glClearStencil( GLint s );



 



extern  void   glTexGend( GLenum coord, GLenum pname, GLdouble param );
extern  void   glTexGenf( GLenum coord, GLenum pname, GLfloat param );
extern  void   glTexGeni( GLenum coord, GLenum pname, GLint param );

extern  void   glTexGendv( GLenum coord, GLenum pname, const GLdouble *params );
extern  void   glTexGenfv( GLenum coord, GLenum pname, const GLfloat *params );
extern  void   glTexGeniv( GLenum coord, GLenum pname, const GLint *params );

extern  void   glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params );
extern  void   glGetTexGenfv( GLenum coord, GLenum pname, GLfloat *params );
extern  void   glGetTexGeniv( GLenum coord, GLenum pname, GLint *params );


extern  void   glTexEnvf( GLenum target, GLenum pname, GLfloat param );
extern  void   glTexEnvi( GLenum target, GLenum pname, GLint param );

extern  void   glTexEnvfv( GLenum target, GLenum pname, const GLfloat *params );
extern  void   glTexEnviv( GLenum target, GLenum pname, const GLint *params );

extern  void   glGetTexEnvfv( GLenum target, GLenum pname, GLfloat *params );
extern  void   glGetTexEnviv( GLenum target, GLenum pname, GLint *params );


extern  void   glTexParameterf( GLenum target, GLenum pname, GLfloat param );
extern  void   glTexParameteri( GLenum target, GLenum pname, GLint param );

extern  void   glTexParameterfv( GLenum target, GLenum pname,
                                          const GLfloat *params );
extern  void   glTexParameteriv( GLenum target, GLenum pname,
                                          const GLint *params );

extern  void   glGetTexParameterfv( GLenum target,
                                           GLenum pname, GLfloat *params);
extern  void   glGetTexParameteriv( GLenum target,
                                           GLenum pname, GLint *params );

extern  void   glGetTexLevelParameterfv( GLenum target, GLint level,
                                                GLenum pname, GLfloat *params );
extern  void   glGetTexLevelParameteriv( GLenum target, GLint level,
                                                GLenum pname, GLint *params );


extern  void   glTexImage1D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLint border,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

extern  void   glTexImage2D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLsizei height,
                                    GLint border, GLenum format, GLenum type,
                                    const GLvoid *pixels );

extern  void   glGetTexImage( GLenum target, GLint level,
                                     GLenum format, GLenum type,
                                     GLvoid *pixels );



 

extern  void   glGenTextures( GLsizei n, GLuint *textures );

extern  void   glDeleteTextures( GLsizei n, const GLuint *textures);

extern  void   glBindTexture( GLenum target, GLuint texture );

extern  void   glPrioritizeTextures( GLsizei n,
                                            const GLuint *textures,
                                            const GLclampf *priorities );

extern  GLboolean   glAreTexturesResident( GLsizei n,
                                                  const GLuint *textures,
                                                  GLboolean *residences );

extern  GLboolean   glIsTexture( GLuint texture );


extern  void   glTexSubImage1D( GLenum target, GLint level,
                                       GLint xoffset,
                                       GLsizei width, GLenum format,
                                       GLenum type, const GLvoid *pixels );


extern  void   glTexSubImage2D( GLenum target, GLint level,
                                       GLint xoffset, GLint yoffset,
                                       GLsizei width, GLsizei height,
                                       GLenum format, GLenum type,
                                       const GLvoid *pixels );


extern  void   glCopyTexImage1D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLint border );


extern  void   glCopyTexImage2D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLsizei height,
                                        GLint border );


extern  void   glCopyTexSubImage1D( GLenum target, GLint level,
                                           GLint xoffset, GLint x, GLint y,
                                           GLsizei width );


extern  void   glCopyTexSubImage2D( GLenum target, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint x, GLint y,
                                           GLsizei width, GLsizei height );




 



extern  void   glMap1d( GLenum target, GLdouble u1, GLdouble u2,
                               GLint stride,
                               GLint order, const GLdouble *points );
extern  void   glMap1f( GLenum target, GLfloat u1, GLfloat u2,
                               GLint stride,
                               GLint order, const GLfloat *points );

extern  void   glMap2d( GLenum target,
		     GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
		     GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
		     const GLdouble *points );
extern  void   glMap2f( GLenum target,
		     GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
		     GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
		     const GLfloat *points );

extern  void   glGetMapdv( GLenum target, GLenum query, GLdouble *v );
extern  void   glGetMapfv( GLenum target, GLenum query, GLfloat *v );
extern  void   glGetMapiv( GLenum target, GLenum query, GLint *v );

extern  void   glEvalCoord1d( GLdouble u );
extern  void   glEvalCoord1f( GLfloat u );

extern  void   glEvalCoord1dv( const GLdouble *u );
extern  void   glEvalCoord1fv( const GLfloat *u );

extern  void   glEvalCoord2d( GLdouble u, GLdouble v );
extern  void   glEvalCoord2f( GLfloat u, GLfloat v );

extern  void   glEvalCoord2dv( const GLdouble *u );
extern  void   glEvalCoord2fv( const GLfloat *u );

extern  void   glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 );
extern  void   glMapGrid1f( GLint un, GLfloat u1, GLfloat u2 );

extern  void   glMapGrid2d( GLint un, GLdouble u1, GLdouble u2,
                                   GLint vn, GLdouble v1, GLdouble v2 );
extern  void   glMapGrid2f( GLint un, GLfloat u1, GLfloat u2,
                                   GLint vn, GLfloat v1, GLfloat v2 );

extern  void   glEvalPoint1( GLint i );

extern  void   glEvalPoint2( GLint i, GLint j );

extern  void   glEvalMesh1( GLenum mode, GLint i1, GLint i2 );

extern  void   glEvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );



 



extern  void   glFogf( GLenum pname, GLfloat param );

extern  void   glFogi( GLenum pname, GLint param );

extern  void   glFogfv( GLenum pname, const GLfloat *params );

extern  void   glFogiv( GLenum pname, const GLint *params );



 



extern  void   glFeedbackBuffer( GLsizei size, GLenum type, GLfloat *buffer );

extern  void   glPassThrough( GLfloat token );

extern  void   glSelectBuffer( GLsizei size, GLuint *buffer );

extern  void   glInitNames( void );

extern  void   glLoadName( GLuint name );

extern  void   glPushName( GLuint name );

extern  void   glPopName( void );



 
extern  void   glDrawRangeElements( GLenum mode, GLuint start,
	GLuint end, GLsizei count, GLenum type, const GLvoid *indices );

extern  void   glTexImage3D( GLenum target, GLint level,
                                      GLint internalFormat,
                                      GLsizei width, GLsizei height,
                                      GLsizei depth, GLint border,
                                      GLenum format, GLenum type,
                                      const GLvoid *pixels );

extern  void   glTexSubImage3D( GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint zoffset, GLsizei width,
                                         GLsizei height, GLsizei depth,
                                         GLenum format,
                                         GLenum type, const GLvoid *pixels);

extern  void   glCopyTexSubImage3D( GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLint zoffset, GLint x,
                                             GLint y, GLsizei width,
                                             GLsizei height );


 

extern  void   glColorTable( GLenum target, GLenum internalformat,
                                    GLsizei width, GLenum format,
                                    GLenum type, const GLvoid *table );

extern  void   glColorSubTable( GLenum target,
                                       GLsizei start, GLsizei count,
                                       GLenum format, GLenum type,
                                       const GLvoid *data );

extern  void   glColorTableParameteriv(GLenum target, GLenum pname,
                                              const GLint *params);

extern  void   glColorTableParameterfv(GLenum target, GLenum pname,
                                              const GLfloat *params);

extern  void   glCopyColorSubTable( GLenum target, GLsizei start,
                                           GLint x, GLint y, GLsizei width );

extern  void   glCopyColorTable( GLenum target, GLenum internalformat,
                                        GLint x, GLint y, GLsizei width );

extern  void   glGetColorTable( GLenum target, GLenum format,
                                       GLenum type, GLvoid *table );

extern  void   glGetColorTableParameterfv( GLenum target, GLenum pname,
                                                  GLfloat *params );

extern  void   glGetColorTableParameteriv( GLenum target, GLenum pname,
                                                  GLint *params );

extern  void   glBlendEquation( GLenum mode );

extern  void   glBlendColor( GLclampf red, GLclampf green,
                                    GLclampf blue, GLclampf alpha );

extern  void   glHistogram( GLenum target, GLsizei width,
				   GLenum internalformat, GLboolean sink );

extern  void   glResetHistogram( GLenum target );

extern  void   glGetHistogram( GLenum target, GLboolean reset,
				      GLenum format, GLenum type,
				      GLvoid *values );

extern  void   glGetHistogramParameterfv( GLenum target, GLenum pname,
						 GLfloat *params );

extern  void   glGetHistogramParameteriv( GLenum target, GLenum pname,
						 GLint *params );

extern  void   glMinmax( GLenum target, GLenum internalformat,
				GLboolean sink );

extern  void   glResetMinmax( GLenum target );

extern  void   glGetMinmax( GLenum target, GLboolean reset,
                                   GLenum format, GLenum types,
                                   GLvoid *values );

extern  void   glGetMinmaxParameterfv( GLenum target, GLenum pname,
					      GLfloat *params );

extern  void   glGetMinmaxParameteriv( GLenum target, GLenum pname,
					      GLint *params );

extern  void   glConvolutionFilter1D( GLenum target,
	GLenum internalformat, GLsizei width, GLenum format, GLenum type,
	const GLvoid *image );

extern  void   glConvolutionFilter2D( GLenum target,
	GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
	GLenum type, const GLvoid *image );

extern  void   glConvolutionParameterf( GLenum target, GLenum pname,
	GLfloat params );

extern  void   glConvolutionParameterfv( GLenum target, GLenum pname,
	const GLfloat *params );

extern  void   glConvolutionParameteri( GLenum target, GLenum pname,
	GLint params );

extern  void   glConvolutionParameteriv( GLenum target, GLenum pname,
	const GLint *params );

extern  void   glCopyConvolutionFilter1D( GLenum target,
	GLenum internalformat, GLint x, GLint y, GLsizei width );

extern  void   glCopyConvolutionFilter2D( GLenum target,
	GLenum internalformat, GLint x, GLint y, GLsizei width,
	GLsizei height);

extern  void   glGetConvolutionFilter( GLenum target, GLenum format,
	GLenum type, GLvoid *image );

extern  void   glGetConvolutionParameterfv( GLenum target, GLenum pname,
	GLfloat *params );

extern  void   glGetConvolutionParameteriv( GLenum target, GLenum pname,
	GLint *params );

extern  void   glSeparableFilter2D( GLenum target,
	GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
	GLenum type, const GLvoid *row, const GLvoid *column );

extern  void   glGetSeparableFilter( GLenum target, GLenum format,
	GLenum type, GLvoid *row, GLvoid *column, GLvoid *span );



 









































extern  void   glActiveTextureARB(GLenum texture);
extern  void   glClientActiveTextureARB(GLenum texture);
extern  void   glMultiTexCoord1dARB(GLenum target, GLdouble s);
extern  void   glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
extern  void   glMultiTexCoord1fARB(GLenum target, GLfloat s);
extern  void   glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
extern  void   glMultiTexCoord1iARB(GLenum target, GLint s);
extern  void   glMultiTexCoord1ivARB(GLenum target, const GLint *v);
extern  void   glMultiTexCoord1sARB(GLenum target, GLshort s);
extern  void   glMultiTexCoord1svARB(GLenum target, const GLshort *v);
extern  void   glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
extern  void   glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
extern  void   glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
extern  void   glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
extern  void   glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
extern  void   glMultiTexCoord2ivARB(GLenum target, const GLint *v);
extern  void   glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
extern  void   glMultiTexCoord2svARB(GLenum target, const GLshort *v);
extern  void   glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern  void   glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
extern  void   glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern  void   glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
extern  void   glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
extern  void   glMultiTexCoord3ivARB(GLenum target, const GLint *v);
extern  void   glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
extern  void   glMultiTexCoord3svARB(GLenum target, const GLshort *v);
extern  void   glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern  void   glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
extern  void   glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern  void   glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
extern  void   glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern  void   glMultiTexCoord4ivARB(GLenum target, const GLint *v);
extern  void   glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern  void   glMultiTexCoord4svARB(GLenum target, const GLshort *v);






//#2243 "/usr/X11R6/include/GL/gl.h"


//#1 "/usr/X11R6/include/GL/glext.h" 1







 





































 

 


//#141 "/usr/X11R6/include/GL/glext.h"


//#179 "/usr/X11R6/include/GL/glext.h"


































































































































































































































































































































































































































































































































































































































































































































































































































 













































































































































































































































































































































































 
 
 
 
 






 
























































































































































 

//#1593 "/usr/X11R6/include/GL/glext.h"


//#1667 "/usr/X11R6/include/GL/glext.h"










typedef void (  * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void (  * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);
typedef void (  * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void (  * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);








typedef void (  * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
typedef void (  * PFNGLSAMPLEPASSARBPROC) (GLenum pass);












//#1711 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (  * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (  * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (  * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (  * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (  * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (  * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, void *img);











typedef void (  * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);







typedef void (  * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);












typedef void (  * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (  * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);








typedef void (  * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat *weights);
typedef void (  * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);








typedef void (  * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (  * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);











typedef void (  * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (  * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (  * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (  * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (  * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);




//#1804 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (  * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (  * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (  * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (  * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (  * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (  * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void (  * PFNGLRESETMINMAXEXTPROC) (GLenum target);




//#1833 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void (  * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void (  * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void (  * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (  * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint params);
typedef void (  * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (  * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (  * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (  * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void (  * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (  * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void (  * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);








//#1863 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void (  * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (  * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (  * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (  * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void (  * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint *params);







typedef void (  * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);












typedef void (  * PFNGLPIXELTEXGENPARAMETERISGISPROC) (GLenum pname, GLint param);
typedef void (  * PFNGLPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, const GLint *params);
typedef void (  * PFNGLPIXELTEXGENPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void (  * PFNGLPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
typedef void (  * PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, GLint *params);
typedef void (  * PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, GLfloat *params);








typedef void (  * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (  * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);




















typedef GLboolean (  * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint *textures, GLboolean *residences);
typedef void (  * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void (  * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint *textures);
typedef void (  * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint *textures);
typedef GLboolean (  * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void (  * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint *textures, const GLclampf *priorities);








typedef void (  * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void (  * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat *points);








typedef void (  * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void (  * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
















typedef void (  * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void (  * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);








//#1989 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (  * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (  * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (  * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (  * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (  * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (  * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (  * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (  * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);































typedef void (  * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);






























typedef void (  * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (  * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void (  * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void (  * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, const GLint *params);














typedef void (  * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void (  * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat *params);
typedef void (  * PFNGLPOINTPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void (  * PFNGLPOINTPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);












typedef GLint (  * PFNGLGETINSTRUMENTSSGIXPROC) (void);
typedef void (  * PFNGLINSTRUMENTSBUFFERSGIXPROC) (GLsizei size, GLint *buffer);
typedef GLint (  * PFNGLPOLLINSTRUMENTSSGIXPROC) (GLint *marker_p);
typedef void (  * PFNGLREADINSTRUMENTSSGIXPROC) (GLint marker);
typedef void (  * PFNGLSTARTINSTRUMENTSSGIXPROC) (void);
typedef void (  * PFNGLSTOPINSTRUMENTSSGIXPROC) (GLint marker);











typedef void (  * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);







typedef void (  * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);










typedef void (  * PFNGLDEFORMATIONMAP3DSGIXPROC) (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
typedef void (  * PFNGLDEFORMATIONMAP3FSGIXPROC) (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
typedef void (  * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void (  * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);







typedef void (  * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble *equation);







typedef void (  * PFNGLFLUSHRASTERSGIXPROC) (void);












typedef void (  * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat *points);
typedef void (  * PFNGLGETFOGFUNCSGISPROC) (const GLfloat *points);
















typedef void (  * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, GLint param);
typedef void (  * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (  * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (  * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (  * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (  * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, GLfloat *params);
















typedef void (  * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void (  * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);











typedef void (  * PFNGLHINTPGIPROC) (GLenum target, GLint mode);










typedef void (  * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void (  * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (  * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (  * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
















typedef void (  * PFNGLGETLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, GLint *params);
typedef void (  * PFNGLLISTPARAMETERFSGIXPROC) (GLuint list, GLenum pname, GLfloat param);
typedef void (  * PFNGLLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, const GLfloat *params);
typedef void (  * PFNGLLISTPARAMETERISGIXPROC) (GLuint list, GLenum pname, GLint param);
typedef void (  * PFNGLLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, const GLint *params);



























typedef void (  * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);







typedef void (  * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLclampf ref);












typedef void (  * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void (  * PFNGLUNLOCKARRAYSEXTPROC) (void);








typedef void (  * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble *params);
typedef void (  * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat *params);








//#2340 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void (  * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (  * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, const GLfloat *params);
typedef void (  * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void (  * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, const GLint *params);
typedef void (  * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (  * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void (  * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void (  * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, const GLint *params);
typedef void (  * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, GLfloat param);
typedef void (  * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat *params);
typedef void (  * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, GLint param);
typedef void (  * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint *params);
typedef void (  * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint *params);
typedef void (  * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint *params);
typedef void (  * PFNGLLIGHTENVISGIXPROC) (GLenum pname, GLint param);















typedef void (  * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

















typedef void (  * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void (  * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void (  * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);




















typedef void (  * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint (  * PFNGLFINISHASYNCSGIXPROC) (GLuint *markerp);
typedef GLint (  * PFNGLPOLLASYNCSGIXPROC) (GLuint *markerp);
typedef GLuint (  * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef void (  * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLboolean (  * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);


















typedef void (  * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void (  * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const GLvoid* *pointer);
typedef void (  * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void (  * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);














typedef void (  * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void (  * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (  * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (  * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
















//#2495 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (  * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void (  * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (  * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void (  * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (  * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void (  * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void (  * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void (  * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (  * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void (  * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (  * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void (  * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (  * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void (  * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (  * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void (  * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);







typedef void (  * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);








typedef void (  * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
typedef void (  * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);











typedef void (  * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void (  * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
typedef void (  * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void (  * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void (  * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);








//#2578 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLTANGENT3BEXTPROC) (GLbyte tx, GLbyte ty, GLbyte tz);
typedef void (  * PFNGLTANGENT3BVEXTPROC) (const GLbyte *v);
typedef void (  * PFNGLTANGENT3DEXTPROC) (GLdouble tx, GLdouble ty, GLdouble tz);
typedef void (  * PFNGLTANGENT3DVEXTPROC) (const GLdouble *v);
typedef void (  * PFNGLTANGENT3FEXTPROC) (GLfloat tx, GLfloat ty, GLfloat tz);
typedef void (  * PFNGLTANGENT3FVEXTPROC) (const GLfloat *v);
typedef void (  * PFNGLTANGENT3IEXTPROC) (GLint tx, GLint ty, GLint tz);
typedef void (  * PFNGLTANGENT3IVEXTPROC) (const GLint *v);
typedef void (  * PFNGLTANGENT3SEXTPROC) (GLshort tx, GLshort ty, GLshort tz);
typedef void (  * PFNGLTANGENT3SVEXTPROC) (const GLshort *v);
typedef void (  * PFNGLBINORMAL3BEXTPROC) (GLbyte bx, GLbyte by, GLbyte bz);
typedef void (  * PFNGLBINORMAL3BVEXTPROC) (const GLbyte *v);
typedef void (  * PFNGLBINORMAL3DEXTPROC) (GLdouble bx, GLdouble by, GLdouble bz);
typedef void (  * PFNGLBINORMAL3DVEXTPROC) (const GLdouble *v);
typedef void (  * PFNGLBINORMAL3FEXTPROC) (GLfloat bx, GLfloat by, GLfloat bz);
typedef void (  * PFNGLBINORMAL3FVEXTPROC) (const GLfloat *v);
typedef void (  * PFNGLBINORMAL3IEXTPROC) (GLint bx, GLint by, GLint bz);
typedef void (  * PFNGLBINORMAL3IVEXTPROC) (const GLint *v);
typedef void (  * PFNGLBINORMAL3SEXTPROC) (GLshort bx, GLshort by, GLshort bz);
typedef void (  * PFNGLBINORMAL3SVEXTPROC) (const GLshort *v);
typedef void (  * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (  * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);























typedef void (  * PFNGLFINISHTEXTURESUNXPROC) (void);




//#2638 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void (  * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void (  * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void (  * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void (  * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void (  * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void (  * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
typedef void (  * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);




//#2659 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void (  * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void (  * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void (  * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint *code);
typedef void (  * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort *code);
typedef void (  * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte *code);
typedef void (  * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid* *pointer);




//#2712 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void (  * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void (  * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void (  * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *v);
typedef void (  * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (  * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat *tc, const GLubyte *c, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (  * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLenum rc, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLenum rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLenum *rc, const GLubyte *c, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLenum rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *c, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLenum rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLenum rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLenum rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *tc, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLenum rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void (  * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLenum rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLenum *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);







typedef void (  * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);













































typedef void (  * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void (  * PFNGLVERTEXWEIGHTFVEXTPROC) (const GLfloat *weight);
typedef void (  * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);












typedef void (  * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void (  * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei size, const GLvoid *pointer);




//#2841 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat *params);
typedef void (  * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (  * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
typedef void (  * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (  * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (  * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (  * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (  * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
typedef void (  * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint *params);
typedef void (  * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat *params);
typedef void (  * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint *params);























typedef void (  * PFNGLRESIZEBUFFERSMESAPROC) (void);




//#2908 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void (  * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble *v);
typedef void (  * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void (  * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat *v);
typedef void (  * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void (  * PFNGLWINDOWPOS2IVMESAPROC) (const GLint *v);
typedef void (  * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void (  * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort *v);
typedef void (  * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (  * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble *v);
typedef void (  * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (  * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat *v);
typedef void (  * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void (  * PFNGLWINDOWPOS3IVMESAPROC) (const GLint *v);
typedef void (  * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void (  * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort *v);
typedef void (  * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (  * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble *v);
typedef void (  * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (  * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat *v);
typedef void (  * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void (  * PFNGLWINDOWPOS4IVMESAPROC) (const GLint *v);
typedef void (  * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (  * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort *v);












typedef void (  * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void (  * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount, GLint modestride);




//#2960 "/usr/X11R6/include/GL/glext.h"

typedef void (  * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void (  * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void (  * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean* *pointer, GLint ptrstride);
typedef void (  * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void (  * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void (  * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void (  * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void (  * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);































typedef void (  * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);








typedef void (  * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void (  * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);























typedef void (  * PFNGLTEXTURECOLORMASKSGISPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);







typedef void (  * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const GLvoid *params);












//#2245 "/usr/X11R6/include/GL/gl.h" 2






 









 









//#53 "SDL_sysvideo.h" 2




 
typedef struct SDL_VideoDevice SDL_VideoDevice;

 




struct SDL_VideoDevice {
	 
	 
	const char *name;

	 
	 

	 


	int (*VideoInit)(SDL_VideoDevice *_this , SDL_PixelFormat *vformat);

	 


	SDL_Rect **(*ListModes)(SDL_VideoDevice *_this , SDL_PixelFormat *format, Uint32 flags);

	 







	SDL_Surface *(*SetVideoMode)(SDL_VideoDevice *_this , SDL_Surface *current,
				int width, int height, int bpp, Uint32 flags);

	 
	int (*ToggleFullScreen)(SDL_VideoDevice *_this , int on);

	 



	void (*UpdateMouse)(SDL_VideoDevice *_this );

	 



	SDL_Overlay *(*CreateYUVOverlay)(SDL_VideoDevice *_this , int width, int height,
	                                 Uint32 format, SDL_Surface *display);

         







	int (*SetColors)(SDL_VideoDevice *_this , int firstcolor, int ncolors,
			 SDL_Color *colors);

	 


	void (*UpdateRects)(SDL_VideoDevice *_this , int numrects, SDL_Rect *rects);

	 


	void (*VideoQuit)(SDL_VideoDevice *_this );

	 
	 

	 
	SDL_VideoInfo info;

	 
	int (*AllocHWSurface)(SDL_VideoDevice *_this , SDL_Surface *surface);

	 


	int (*CheckHWBlit)(SDL_VideoDevice *_this , SDL_Surface *src, SDL_Surface *dst);

	 
	int (*FillHWRect)(SDL_VideoDevice *_this , SDL_Surface *dst, SDL_Rect *rect, Uint32 color);

	 
	int (*SetHWColorKey)(SDL_VideoDevice *_this , SDL_Surface *surface, Uint32 key);

	 
	int (*SetHWAlpha)(SDL_VideoDevice *_this , SDL_Surface *surface, Uint8 value);

	 
	int (*LockHWSurface)(SDL_VideoDevice *_this , SDL_Surface *surface);
	void (*UnlockHWSurface)(SDL_VideoDevice *_this , SDL_Surface *surface);

	 
	int (*FlipHWSurface)(SDL_VideoDevice *_this , SDL_Surface *surface);

	 
	void (*FreeHWSurface)(SDL_VideoDevice *_this , SDL_Surface *surface);

	 
	 

	Uint16 *gamma;

	 
	int (*SetGamma)(SDL_VideoDevice *_this , float red, float green, float blue);

	 
	int (*GetGamma)(SDL_VideoDevice *_this , float *red, float *green, float *blue);

	 
	int (*SetGammaRamp)(SDL_VideoDevice *_this , Uint16 *ramp);

	 
	int (*GetGammaRamp)(SDL_VideoDevice *_this , Uint16 *ramp);

	 
	 

	 
	int (*GL_LoadLibrary)(SDL_VideoDevice *_this , const char *path);

	 
	void* (*GL_GetProcAddress)(SDL_VideoDevice *_this , const char *proc);

         
        int (*GL_GetAttribute)(SDL_VideoDevice *_this , SDL_GLattr attrib, int* value);

         
        int (*GL_MakeCurrent)(SDL_VideoDevice *_this );

	 
	void (*GL_SwapBuffers)(SDL_VideoDevice *_this );

  	 





//#1 "SDL_glfuncs.h" 1
 




 
 
 
 
 void  (  * glBegin )  (GLenum) ; 
 void  (  * glBindTexture )  (GLenum,GLuint) ; 
 
 void  (  * glBlendFunc )  (GLenum,GLenum) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glColor4f )  (GLfloat,GLfloat,GLfloat,GLfloat) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glCopyTexImage1D )  (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border) ; 
 
 
 
 
 
 
 
 
 
 void  (  * glDisable )  (GLenum cap) ; 
 
 
 
 
 
 
 
 
 void  (  * glEnable )  (GLenum cap) ; 
 
 void  (  * glEnd )  (void) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glFlush )  (void) ; 
 
 
 
 
 
 
 
 void  (  * glGenTextures )  (GLsizei n, GLuint *textures) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 const GLubyte *  (  * glGetString )  (GLenum name) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glLoadIdentity )  (void) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glMatrixMode )  (GLenum mode) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glOrtho )  (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) ; 
 
 
 
 
 
 void  (  * glPixelStorei )  (GLenum pname, GLint param) ; 
 
 
 
 
 
 
 
 void  (  * glPopAttrib )  (void) ; 
 void  (  * glPopClientAttrib )  (void) ; 
 void  (  * glPopMatrix )  (void) ; 
 
 
 void  (  * glPushAttrib )  (GLbitfield mask) ; 
 void  (  * glPushClientAttrib )  (GLbitfield mask) ; 
 void  (  * glPushMatrix )  (void) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glTexCoord2f )  (GLfloat s, GLfloat t) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glTexEnvf )  (GLenum target, GLenum pname, GLfloat param) ; 
 
 
 
 
 
 
 
 
 
 
 void  (  * glTexImage2D )  (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) ; 
 
 
 void  (  * glTexParameteri )  (GLenum target, GLenum pname, GLint param) ; 
 
 
 void  (  * glTexSubImage2D )  (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) ; 
 
 
 
 
 
 
 void  (  * glVertex2i )  (GLint x, GLint y) ; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 void  (  * glViewport )  (GLint x, GLint y, GLsizei width, GLsizei height) ; 
//#205 "SDL_sysvideo.h" 2



	 
	GLuint texture;

	int is_32bit;
 
	 
	 

	 
	void (*SetCaption)(SDL_VideoDevice *_this , const char *title, const char *icon);

	 
	void (*SetIcon)(SDL_VideoDevice *_this , SDL_Surface *icon, Uint8 *mask);

	 



	int (*IconifyWindow)(SDL_VideoDevice *_this );

	 
	SDL_GrabMode (*GrabInput)(SDL_VideoDevice *_this , SDL_GrabMode mode);

	 
	int (*GetWMInfo)(SDL_VideoDevice *_this , SDL_SysWMinfo *info);

	 
	 

	 


	void (*FreeWMCursor)(SDL_VideoDevice *_this , WMcursor *cursor);

	 
	WMcursor *(*CreateWMCursor)(SDL_VideoDevice *_this ,
		Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);

	 
	int (*ShowWMCursor)(SDL_VideoDevice *_this , WMcursor *cursor);

	 


	void (*WarpWMCursor)(SDL_VideoDevice *_this , Uint16 x, Uint16 y);

	 
	void (*MoveWMCursor)(SDL_VideoDevice *_this , int x, int y);

	 






	void (*CheckMouseMode)(SDL_VideoDevice *_this );

	 
	 

	 
	void (*InitOSKeymap)(SDL_VideoDevice *_this );

	 
	void (*PumpEvents)(SDL_VideoDevice *_this );

	 
	 
	SDL_Surface *screen;
	SDL_Surface *shadow;
	SDL_Surface *visible;
        SDL_Palette *physpal;	 
        SDL_Color *gammacols;	 
	char *wm_title;
	char *wm_icon;
	int offset_x;
	int offset_y;
	SDL_GrabMode input_grab;

	 
	int handles_any_size;	 

	 
	 
	struct {
		int red_size;
		int green_size;
		int blue_size;
		int alpha_size;
		int depth_size;
		int buffer_size;
		int stencil_size;
		int double_buffer;
		int accum_red_size;
		int accum_green_size;
		int accum_blue_size;
		int accum_alpha_size;
		int stereo;
		int multisamplebuffers;
		int multisamplesamples;
		int driver_loaded;
		char driver_path[256];
		void* dll_handle;
	} gl_config;

	 
	 
	struct SDL_PrivateVideoData *hidden;
	struct SDL_PrivateGLData *gl_data;

	 
	 
	void (*free)(SDL_VideoDevice *_this );
};


typedef struct VideoBootStrap {
	const char *name;
	const char *desc;
	int (*available)(void);
	SDL_VideoDevice *(*create)(int devindex);
} VideoBootStrap;


extern VideoBootStrap X11_bootstrap;


extern VideoBootStrap DGA_bootstrap;





extern VideoBootStrap FBCON_bootstrap;




























 

























extern VideoBootStrap DUMMY_bootstrap;



















 
extern SDL_VideoDevice *current_video;






//#100 "SDL_RLEaccel.c" 2

//#1 "SDL_blit.h" 1
 





























//#1 "../../include/SDL_endian.h" 1
 


























 




 













//#1 "../../include/SDL_types.h" 1
 


























 

//#110 "../../include/SDL_types.h"

//#47 "../../include/SDL_endian.h" 2

//#1 "../../include/SDL_rwops.h" 1
 


























 



//#113 "../../include/SDL_rwops.h"

//#48 "../../include/SDL_endian.h" 2

//#1 "../../include/SDL_byteorder.h" 1
 


























 




 



 

















//#49 "../../include/SDL_endian.h" 2


//#1 "../../include/begin_code.h" 1
 





















 




 





 




 
//#62 "../../include/begin_code.h"


 








 





 




//#95 "../../include/begin_code.h"


 
//#117 "../../include/begin_code.h"


 







 









//#51 "../../include/SDL_endian.h" 2

 




 
 

//#1 "/usr/include/asm/byteorder.h" 1 3



//#1 "/usr/include/asm/types.h" 1 3



typedef unsigned short umode_t;

 




typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


typedef __signed__ long long __s64;
typedef unsigned long long __u64;


 


//#55 "/usr/include/asm/types.h" 3



//#4 "/usr/include/asm/byteorder.h" 2 3




 




static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
{



	__asm__("xchgb %b0,%h0\n\t"	 
		"rorl $16,%0\n\t"	 
		"xchgb %b0,%h0"		 
		:"=q" (x)
		: "0" (x));

	return x;
}

 

static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
{
	__asm__("xchgb %b0,%h0"		 
		: "=q" (x)
		:  "0" (x));
		return x;
}


static inline __u64 ___arch__swab64(__u64 val) 
{ 
	union { 
		struct { __u32 a,b; } s;
		__u64 u;
	} v;
	v.u = val;





   v.s.a = ___arch__swab32(v.s.a); 
	v.s.b = ___arch__swab32(v.s.b); 
	asm("xchgl %0,%1" : "=r" (v.s.a), "=r" (v.s.b) : "0" (v.s.a), "1" (v.s.b));

	return v.u;	
} 









//#1 "/usr/include/linux/byteorder/little_endian.h" 1 3










//#1 "/usr/include/linux/byteorder/swab.h" 1 3



 













 




















//#47 "/usr/include/linux/byteorder/swab.h" 3


//#61 "/usr/include/linux/byteorder/swab.h" 3

















//#87 "/usr/include/linux/byteorder/swab.h" 3

 










































 



























static __inline__ __const__ __u16 __fswab16(__u16 x)
{
	return ___arch__swab16( x ) ;
}
static __inline__ __u16 __swab16p(__u16 *x)
{
	return ___arch__swab16( *( x ) )  ;
}
static __inline__ void __swab16s(__u16 *addr)
{
	do { *( addr ) = ___arch__swab16( *( ( addr ) ) )  ; } while (0) ;
}

static __inline__ __const__ __u32 __fswab24(__u32 x)
{
	return ({ __u32 __tmp = ( x ) ; ({ __u32 __x = ( __tmp ); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL)        | ((__x & (__u32)0x00ff0000UL) >> 16) )); }) ; }) ;
}
static __inline__ __u32 __swab24p(__u32 *x)
{
	return ({ __u32 __tmp = ( *( x ) ) ; ({ __u32 __x = ( __tmp ); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL)        | ((__x & (__u32)0x00ff0000UL) >> 16) )); }) ; })  ;
}
static __inline__ void __swab24s(__u32 *addr)
{
	do { *( addr ) = ({ __u32 __tmp = ( *( ( addr ) ) ) ; ({ __u32 __x = ( __tmp ); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL)        | ((__x & (__u32)0x00ff0000UL) >> 16) )); }) ; })  ; } while (0) ;
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
	return ___arch__swab32( x ) ;
}
static __inline__ __u32 __swab32p(__u32 *x)
{
	return ___arch__swab32( *( x ) )  ;
}
static __inline__ void __swab32s(__u32 *addr)
{
	do { *( addr ) = ___arch__swab32( *( ( addr ) ) )  ; } while (0) ;
}


static __inline__ __const__ __u64 __fswab64(__u64 x)
{





	return ___arch__swab64( x ) ;

}
static __inline__ __u64 __swab64p(__u64 *x)
{
	return ___arch__swab64( *( x ) )  ;
}
static __inline__ void __swab64s(__u64 *addr)
{
	do { *( addr ) = ___arch__swab64( *( ( addr ) ) )  ; } while (0) ;
}


//#232 "/usr/include/linux/byteorder/swab.h" 3



//#11 "/usr/include/linux/byteorder/little_endian.h" 2 3







































































//#1 "/usr/include/linux/byteorder/generic.h" 1 3



 




































 








































//#123 "/usr/include/linux/byteorder/generic.h" 3



 


















 




extern __u32			ntohl(__u32);
extern __u32			htonl(__u32);




extern unsigned short int	ntohs(unsigned short int);
extern unsigned short int	htons(unsigned short int);























//#82 "/usr/include/linux/byteorder/little_endian.h" 2 3



//#65 "/usr/include/asm/byteorder.h" 2 3



//#60 "../../include/SDL_endian.h" 2








 
















static __inline__ Uint64 SDL_Swap64(Uint64 val) {
	Uint32 hi, lo;

	 
	lo = (Uint32)(val&0xFFFFFFFF);
	val >>= 32;
	hi = (Uint32)(val&0xFFFFFFFF);
	val = ___arch__swab32( lo ) ;
	val <<= 32;
	val |= ___arch__swab32( hi ) ;
	return(val);
}

//#106 "../../include/SDL_endian.h"



 
















 
extern   Uint16   SDL_ReadLE16(SDL_RWops *src);
extern   Uint16   SDL_ReadBE16(SDL_RWops *src);
extern   Uint32   SDL_ReadLE32(SDL_RWops *src);
extern   Uint32   SDL_ReadBE32(SDL_RWops *src);
extern   Uint64   SDL_ReadLE64(SDL_RWops *src);
extern   Uint64   SDL_ReadBE64(SDL_RWops *src);

 
extern   int   SDL_WriteLE16(SDL_RWops *dst, Uint16 value);
extern   int   SDL_WriteBE16(SDL_RWops *dst, Uint16 value);
extern   int   SDL_WriteLE32(SDL_RWops *dst, Uint32 value);
extern   int   SDL_WriteBE32(SDL_RWops *dst, Uint32 value);
extern   int   SDL_WriteLE64(SDL_RWops *dst, Uint64 value);
extern   int   SDL_WriteBE64(SDL_RWops *dst, Uint64 value);


 



//#1 "../../include/close_code.h" 1
 





















 





 
//#40 "../../include/close_code.h"


//#147 "../../include/SDL_endian.h" 2



//#31 "SDL_blit.h" 2


 
typedef struct {
	Uint8 *s_pixels;
	int s_width;
	int s_height;
	int s_skip;
	Uint8 *d_pixels;
	int d_width;
	int d_height;
	int d_skip;
	void *aux_data;
	SDL_PixelFormat *src;
	Uint8 *table;
	SDL_PixelFormat *dst;
} SDL_BlitInfo;

 
typedef void (*SDL_loblit)(SDL_BlitInfo *info);

 
struct private_swaccel {
	SDL_loblit blit;
	void *aux_data;
};

 
typedef struct SDL_BlitMap {
	SDL_Surface *dst;
	int identity;
	Uint8 *table;
	SDL_blit hw_blit;
	SDL_blit sw_blit;
	struct private_hwaccel *hw_data;
	struct private_swaccel *sw_data;

	 

        unsigned int format_version;
} SDL_BlitMap;


 
extern int SDL_CalculateBlit(SDL_Surface *surface);

 
extern SDL_loblit SDL_CalculateBlit0(SDL_Surface *surface, int complex);
extern SDL_loblit SDL_CalculateBlit1(SDL_Surface *surface, int complex);
extern SDL_loblit SDL_CalculateBlitN(SDL_Surface *surface, int complex);
extern SDL_loblit SDL_CalculateAlphaBlit(SDL_Surface *surface, int complex);

 







 
 

























//#143 "SDL_blit.h"


//#171 "SDL_blit.h"

 



















//#224 "SDL_blit.h"

//#261 "SDL_blit.h"

 




































//#326 "SDL_blit.h"

 








//#368 "SDL_blit.h"

 







 







 

//#400 "SDL_blit.h"

 

//#412 "SDL_blit.h"

 

//#430 "SDL_blit.h"

 

//#453 "SDL_blit.h"

 

//#471 "SDL_blit.h"

 

//#494 "SDL_blit.h"

 

//#512 "SDL_blit.h"

 

//#535 "SDL_blit.h"

 



//#647 "SDL_blit.h"


 





//#101 "SDL_RLEaccel.c" 2

//#1 "SDL_memops.h" 1
 





























 




 


//#55 "SDL_memops.h"


//#66 "SDL_memops.h"


//#91 "SDL_memops.h"











//#111 "SDL_memops.h"



 












//#142 "SDL_memops.h"



//#102 "SDL_RLEaccel.c" 2

//#1 "SDL_RLEaccel_c.h" 1
 


























 

extern int SDL_RLESurface(SDL_Surface *surface);
extern int SDL_RLEBlit(SDL_Surface *src, SDL_Rect *srcrect,
                       SDL_Surface *dst, SDL_Rect *dstrect);
extern int SDL_RLEAlphaBlit(SDL_Surface *src, SDL_Rect *srcrect,
			    SDL_Surface *dst, SDL_Rect *dstrect);
extern void SDL_UnRLESurface(SDL_Surface *surface, int recode);
//#103 "SDL_RLEaccel.c" 2



//#1 "mmx.h" 1
 





























 









 




typedef	union {
	long long		q;	 
	unsigned long long	uq;	 
	int			d[2];	 
	unsigned int		ud[2];	 
	short			w[4];	 
	unsigned short		uw[4];	 
	char			b[8];	 
	unsigned char		ub[8];	 
	float			s[2];	 
} __attribute__ ((aligned (8))) mmx_t;	 


//#227 "mmx.h"


 





//#343 "mmx.h"


 






























 













 














 














 










 










 














 










 










 






 






 








 

//#522 "mmx.h"







 






 






 






 















 















 

















 

















 












 











 







 
















 
















 





//#699 "mmx.h"








//#106 "SDL_RLEaccel.c" 2

 






//#1 "../../src/hermes/HeadX86.h" 1
 














 

 





void   ConvertX86(void  *);
void   ClearX86_32(void  *);
void   ClearX86_24(void  *);
void   ClearX86_16(void  *);
void   ClearX86_8(void  *);

int   Hermes_X86_CPU();

void ConvertX86p32_32BGR888();
void ConvertX86p32_32RGBA888();
void ConvertX86p32_32BGRA888();
void ConvertX86p32_24RGB888();
void ConvertX86p32_24BGR888();
void ConvertX86p32_16RGB565();
void ConvertX86p32_16BGR565();
void ConvertX86p32_16RGB555();
void ConvertX86p32_16BGR555();
void ConvertX86p32_8RGB332();

void ConvertX86p16_32RGB888();
void ConvertX86p16_32BGR888();
void ConvertX86p16_32RGBA888();
void ConvertX86p16_32BGRA888();
void ConvertX86p16_24RGB888();
void ConvertX86p16_24BGR888();
void ConvertX86p16_16BGR565();
void ConvertX86p16_16RGB555();
void ConvertX86p16_16BGR555();
void ConvertX86p16_8RGB332();

void CopyX86p_4byte();
void CopyX86p_3byte();
void CopyX86p_2byte();
void CopyX86p_1byte();

void ConvertX86pI8_32();
void ConvertX86pI8_24();
void ConvertX86pI8_16();

extern int ConvertX86p16_32RGB888_LUT_X86[512];
extern int ConvertX86p16_32BGR888_LUT_X86[512];
extern int ConvertX86p16_32RGBA888_LUT_X86[512];
extern int ConvertX86p16_32BGRA888_LUT_X86[512];
  







 


  



  int Hermes_X86_CPU() __attribute__ ((alias ("_Hermes_X86_CPU")));

  void ConvertX86(void  *) __attribute__ ((alias ("_ConvertX86")));








  void ConvertX86p32_32BGR888() __attribute__ ((alias ("_ConvertX86p32_32BGR888")));
  void ConvertX86p32_32RGBA888() __attribute__ ((alias ("_ConvertX86p32_32RGBA888")));
  void ConvertX86p32_32BGRA888() __attribute__ ((alias ("_ConvertX86p32_32BGRA888")));
  void ConvertX86p32_24RGB888() __attribute__ ((alias ("_ConvertX86p32_24RGB888")));
  void ConvertX86p32_24BGR888() __attribute__ ((alias ("_ConvertX86p32_24BGR888")));
  void ConvertX86p32_16RGB565() __attribute__ ((alias ("_ConvertX86p32_16RGB565")));
  void ConvertX86p32_16BGR565() __attribute__ ((alias ("_ConvertX86p32_16BGR565")));
  void ConvertX86p32_16RGB555() __attribute__ ((alias ("_ConvertX86p32_16RGB555")));
  void ConvertX86p32_16BGR555() __attribute__ ((alias ("_ConvertX86p32_16BGR555")));
  void ConvertX86p32_8RGB332() __attribute__ ((alias ("_ConvertX86p32_8RGB332")));









  void ConvertX86p16_16BGR565() __attribute__ ((alias ("_ConvertX86p16_16BGR565")));
  void ConvertX86p16_16RGB555() __attribute__ ((alias ("_ConvertX86p16_16RGB555")));
  void ConvertX86p16_16BGR555() __attribute__ ((alias ("_ConvertX86p16_16BGR555")));
  void ConvertX86p16_8RGB332() __attribute__ ((alias ("_ConvertX86p16_8RGB332")));

//#131 "../../src/hermes/HeadX86.h"


  







 
//#189 "../../src/hermes/HeadX86.h"







//#114 "SDL_RLEaccel.c" 2



















 









//#221 "SDL_RLEaccel.c"


//#310 "SDL_RLEaccel.c"


//#399 "SDL_RLEaccel.c"



 







//#444 "SDL_RLEaccel.c"

 






//#467 "SDL_RLEaccel.c"


//#484 "SDL_RLEaccel.c"

 



//#544 "SDL_RLEaccel.c"




//#584 "SDL_RLEaccel.c"


    
 








//#607 "SDL_RLEaccel.c"

 




 








 

//#651 "SDL_RLEaccel.c"










//#743 "SDL_RLEaccel.c"

//#814 "SDL_RLEaccel.c"


 



static void RLEClipBlit(int w, Uint8 *srcbuf, SDL_Surface *dst,
			Uint8 *dstbuf, SDL_Rect *srcrect, unsigned alpha)
{
    SDL_PixelFormat *fmt = dst->format;


//#868 "SDL_RLEaccel.c"

    do {	if(  alpha  == 255) {	switch(  fmt ->BytesPerPixel) {	case 1:  do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  1 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy1OPAQUE_BLIT ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	if(     1    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    len  ) )), "1" (   dstbuf + startcol *  1    ), "2" (      srcbuf + start *  1    )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    len  ) * (     1   ) )/4), "q" (  (unsigned)(    len  ) * (     1   ) ), "1" (   dstbuf + startcol *  1    ),"2" (      srcbuf + start *  1    ) : "memory" );	} while(0) ;	}	} while(0)  ;	}	nocopy1OPAQUE_BLIT :	srcbuf += run *  1 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	case 2:  do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2OPAQUE_BLIT ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	if(     2    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    len  ) )), "1" (   dstbuf + startcol *  2    ), "2" (      srcbuf + start *  2    )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    len  ) * (     2   ) )/4), "q" (  (unsigned)(    len  ) * (     2   ) ), "1" (   dstbuf + startcol *  2    ),"2" (      srcbuf + start *  2    ) : "memory" );	} while(0) ;	}	} while(0)  ;	}	nocopy2OPAQUE_BLIT :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	case 3:  do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  3 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy3OPAQUE_BLIT ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	if(     3    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    len  ) )), "1" (   dstbuf + startcol *  3    ), "2" (      srcbuf + start *  3    )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    len  ) * (     3   ) )/4), "q" (  (unsigned)(    len  ) * (     3   ) ), "1" (   dstbuf + startcol *  3    ),"2" (      srcbuf + start *  3    ) : "memory" );	} while(0) ;	}	} while(0)  ;	}	nocopy3OPAQUE_BLIT :	srcbuf += run *  3 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	case 4:  do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  4 ;	for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy4OPAQUE_BLIT ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	if(     4    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    len  ) )), "1" (   dstbuf + startcol *  4    ), "2" (      srcbuf + start *  4    )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    len  ) * (     4   ) )/4), "q" (  (unsigned)(    len  ) * (     4   ) ), "1" (   dstbuf + startcol *  4    ),"2" (      srcbuf + start *  4    ) : "memory" );	} while(0) ;	}	} while(0)  ;	}	nocopy4OPAQUE_BLIT :	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	}	} else {	switch(  fmt ->BytesPerPixel) {	case 1:	break;	case 2:	switch(  fmt ->Rmask |   fmt ->Gmask |   fmt ->Bmask) {	case 0xffff:	if(  fmt ->Gmask == 0x07e0	||   fmt ->Rmask == 0x07e0	||   fmt ->Bmask == 0x07e0) {	if(  alpha  == 128)	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT16_565_50 ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	unsigned n = (    len  );	Uint16 *src = (Uint16 *)(    srcbuf + start *  2   );	Uint16 *dst = (Uint16 *)(  dstbuf + startcol *  2   );	if(((unsigned long)src ^ (unsigned long)dst) & 3) {	while(n--)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xf7de  ) + (d &     0xf7de  )) >> 1)	+ (s & d & (~    0xf7de   & 0xffff));	} while(0) ;	} else {	if((unsigned long)src & 3) {	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xf7de  ) + (d &     0xf7de  )) >> 1)	+ (s & d & (~    0xf7de   & 0xffff));	} while(0) ;	n--;	}	for(; n > 1; n -= 2) {	Uint32 s = *(Uint32 *)src;	Uint32 d = *(Uint32 *)dst;	*(Uint32 *)dst = ((s & (  0xf7de  |   0xf7de  << 16)) >> 1)	+ ((d & (  0xf7de  |   0xf7de  << 16)) >> 1)	+ (s & d & (~(  0xf7de  |   0xf7de  << 16)));	src += 2;	dst += 2;	}	if(n)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xf7de  ) + (d &     0xf7de  )) >> 1)	+ (s & d & (~    0xf7de   & 0xffff));	} while(0) ; }	} while(0)  ;	}	nocopy2ALPHA_BLIT16_565_50 :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else {	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT16_565MMX ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i, n = 0;	Uint16 *srcp = (Uint16 *)(  srcbuf + start *  2  );	Uint16 *dstp = (Uint16 *)( dstbuf + startcol *  2  );	Uint32 ALPHA = 0xF800;	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	ALPHA = 0x07E0;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	ALPHA = 0x001F;	__asm__ __volatile__ ("movd" " %0, %%" "mm7" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	i = (Uint32)  alpha  | (Uint32)  alpha  << 16;	__asm__ __volatile__ ("movd" " %0, %%" "mm0" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm0" ", %" "mm0")  ;	ALPHA =   alpha  >> 3;	i = ((int)(  len ) & 3);	for(; i > 0; --i) {	Uint32 s = *srcp++;	Uint32 d = *dstp;	s = (s | s << 16) & 0x07e0f81f;	d = (d | d << 16) & 0x07e0f81f;	d += (s - d) * ALPHA >> 5;	d &= 0x07e0f81f;	*dstp++ = d | d >> 16;	n++;	}	i = (int)(  len ) - n;	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm3" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   11  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   11  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   11  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %%" "mm3" ", %0" : "=X" (    *dstp  ) :   )  ;	srcp += 4;	dstp += 4;	i -= 3;	}	__asm__ __volatile__ ("emms") ;	} while(0) ;	}	nocopy2ALPHA_BLIT16_565MMX :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT16_565 ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i;	Uint16 *src = (Uint16 *)(  srcbuf + start *  2  );	Uint16 *dst = (Uint16 *)( dstbuf + startcol *  2  );	Uint32 ALPHA =   alpha  >> 3;	for(i = 0; i < (int)(  len ); i++) {	Uint32 s = *src++;	Uint32 d = *dst;	s = (s | s << 16) & 0x07e0f81f;	d = (d | d << 16) & 0x07e0f81f;	d += (s - d) * ALPHA >> 5;	d &= 0x07e0f81f;	*dst++ = d | d >> 16;	}	} while(0) ;	}	nocopy2ALPHA_BLIT16_565 :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	} else	goto general16;	break;	case 0x7fff:	if(  fmt ->Gmask == 0x03e0	||   fmt ->Rmask == 0x03e0	||   fmt ->Bmask == 0x03e0) {	if(  alpha  == 128)	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT16_555_50 ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	unsigned n = (    len  );	Uint16 *src = (Uint16 *)(    srcbuf + start *  2   );	Uint16 *dst = (Uint16 *)(  dstbuf + startcol *  2   );	if(((unsigned long)src ^ (unsigned long)dst) & 3) {	while(n--)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xfbde  ) + (d &     0xfbde  )) >> 1)	+ (s & d & (~    0xfbde   & 0xffff));	} while(0) ;	} else {	if((unsigned long)src & 3) {	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xfbde  ) + (d &     0xfbde  )) >> 1)	+ (s & d & (~    0xfbde   & 0xffff));	} while(0) ;	n--;	}	for(; n > 1; n -= 2) {	Uint32 s = *(Uint32 *)src;	Uint32 d = *(Uint32 *)dst;	*(Uint32 *)dst = ((s & (  0xfbde  |   0xfbde  << 16)) >> 1)	+ ((d & (  0xfbde  |   0xfbde  << 16)) >> 1)	+ (s & d & (~(  0xfbde  |   0xfbde  << 16)));	src += 2;	dst += 2;	}	if(n)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xfbde  ) + (d &     0xfbde  )) >> 1)	+ (s & d & (~    0xfbde   & 0xffff));	} while(0) ; }	} while(0)  ;	}	nocopy2ALPHA_BLIT16_555_50 :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else {	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT16_555MMX ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i, n = 0;	Uint16 *srcp = (Uint16 *)(  srcbuf + start *  2  );	Uint16 *dstp = (Uint16 *)( dstbuf + startcol *  2  );	Uint32 ALPHA = 0x7C00;	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	ALPHA = 0x03E0;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	ALPHA = 0x001F;	__asm__ __volatile__ ("movd" " %0, %%" "mm7" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	i = (Uint32)  alpha  | (Uint32)  alpha  << 16;	__asm__ __volatile__ ("movd" " %0, %%" "mm0" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm0" ", %" "mm0")  ;	i = ((int)(  len ) & 3);	ALPHA =   alpha  >> 3;	for(; i > 0; --i) {	Uint32 s = *srcp++;	Uint32 d = *dstp;	s = (s | s << 16) & 0x03e07c1f;	d = (d | d << 16) & 0x03e07c1f;	d += (s - d) * ALPHA >> 5;	d &= 0x03e07c1f;	*dstp++ = d | d >> 16;	n++;	}	i = (int)(  len ) - n;	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm3" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   10  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   10  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   10  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %%" "mm3" ", %0" : "=X" (    *dstp  ) :   )  ;	srcp += 4;	dstp += 4;	i -= 3;	}	__asm__ __volatile__ ("emms") ;	} while(0) ;	}	nocopy2ALPHA_BLIT16_555MMX :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT16_555 ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i;	Uint16 *src = (Uint16 *)(  srcbuf + start *  2  );	Uint16 *dst = (Uint16 *)( dstbuf + startcol *  2  );	Uint32 ALPHA =   alpha  >> 3;	for(i = 0; i < (int)(  len ); i++) {	Uint32 s = *src++;	Uint32 d = *dst;	s = (s | s << 16) & 0x03e07c1f;	d = (d | d << 16) & 0x03e07c1f;	d += (s - d) * ALPHA >> 5;	d &= 0x03e07c1f;	*dst++ = d | d >> 16;	}	} while(0) ;	}	nocopy2ALPHA_BLIT16_555 :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	break;	}	default:	general16:	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  2 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy2ALPHA_BLIT_ANY ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i;	Uint8 *src =   srcbuf + start *  2  ;	Uint8 *dst =  dstbuf + startcol *  2  ;	for(i = 0; i < (int)(  len ); i++) {	Uint32 s, d;	unsigned rs, gs, bs, rd, gd, bd;	switch(   2  ) {	case 2:	s = *(Uint16 *)src;	d = *(Uint16 *)dst;	break;	case 3:	if(1234   == 4321 ) {	s = (src[0] << 16) | (src[1] << 8) | src[2];	d = (dst[0] << 16) | (dst[1] << 8) | dst[2];	} else {	s = (src[2] << 16) | (src[1] << 8) | src[0];	d = (dst[2] << 16) | (dst[1] << 8) | dst[0];	}	break;	case 4:	s = *(Uint32 *)src;	d = *(Uint32 *)dst;	break;	}	{	  rs  = ((( s &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gs  = ((( s &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bs  = ((( s &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	{	  rd  = ((( d &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gd  = ((( d &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bd  = ((( d &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	rd += (rs - rd) *   alpha  >> 8;	gd += (gs - gd) *   alpha  >> 8;	bd += (bs - bd) *   alpha  >> 8;	{	 d  = ((  rd >>  fmt ->Rloss)<<  fmt ->Rshift)|	((  gd >>  fmt ->Gloss)<<  fmt ->Gshift)|	((  bd >>  fmt ->Bloss)<<  fmt ->Bshift);	} ;	switch(   2  ) {	case 2:	*(Uint16 *)dst = d;	break;	case 3:	if(1234   == 4321 ) {	dst[0] = d >> 16;	dst[1] = d >> 8;	dst[2] = d;	} else {	dst[0] = d;	dst[1] = d >> 8;	dst[2] = d >> 16;	}	break;	case 4:	*(Uint32 *)dst = d;	break;	}	src +=    2  ;	dst +=    2  ;	}	} while(0) ;	}	nocopy2ALPHA_BLIT_ANY :	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	break;	case 3:	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  3 ;	for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy3ALPHA_BLIT_ANY ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i;	Uint8 *src =   srcbuf + start *  3  ;	Uint8 *dst =  dstbuf + startcol *  3  ;	for(i = 0; i < (int)(  len ); i++) {	Uint32 s, d;	unsigned rs, gs, bs, rd, gd, bd;	switch(   3  ) {	case 2:	s = *(Uint16 *)src;	d = *(Uint16 *)dst;	break;	case 3:	if(1234   == 4321 ) {	s = (src[0] << 16) | (src[1] << 8) | src[2];	d = (dst[0] << 16) | (dst[1] << 8) | dst[2];	} else {	s = (src[2] << 16) | (src[1] << 8) | src[0];	d = (dst[2] << 16) | (dst[1] << 8) | dst[0];	}	break;	case 4:	s = *(Uint32 *)src;	d = *(Uint32 *)dst;	break;	}	{	  rs  = ((( s &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gs  = ((( s &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bs  = ((( s &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	{	  rd  = ((( d &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gd  = ((( d &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bd  = ((( d &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	rd += (rs - rd) *   alpha  >> 8;	gd += (gs - gd) *   alpha  >> 8;	bd += (bs - bd) *   alpha  >> 8;	{	 d  = ((  rd >>  fmt ->Rloss)<<  fmt ->Rshift)|	((  gd >>  fmt ->Gloss)<<  fmt ->Gshift)|	((  bd >>  fmt ->Bloss)<<  fmt ->Bshift);	} ;	switch(   3  ) {	case 2:	*(Uint16 *)dst = d;	break;	case 3:	if(1234   == 4321 ) {	dst[0] = d >> 16;	dst[1] = d >> 8;	dst[2] = d;	} else {	dst[0] = d;	dst[1] = d >> 8;	dst[2] = d >> 16;	}	break;	case 4:	*(Uint32 *)dst = d;	break;	}	src +=    3  ;	dst +=    3  ;	}	} while(0) ;	}	nocopy3ALPHA_BLIT_ANY :	srcbuf += run *  3 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	break;	case 4:	if((  fmt ->Rmask |   fmt ->Gmask |   fmt ->Bmask) == 0x00ffffff	&& (  fmt ->Gmask == 0xff00 ||   fmt ->Rmask == 0xff00	||   fmt ->Bmask == 0xff00)) {	if(  alpha  == 128)	{	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  4 ;	for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy4ALPHA_BLIT32_888_50MMX ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	Uint32 *srcp = (Uint32 *)(  srcbuf + start *  4  );	Uint32 *dstp = (Uint32 *)( dstbuf + startcol *  4  );	int i = 0x00fefefe;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm4" ", %" "mm4")  ;	i = 0x00010101;	__asm__ __volatile__ ("movd" " %0, %%" "mm3" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm3" ", %" "mm3")  ;	i = (int)(  len );	if( i & 1 ) {	Uint32 s = *srcp++;	Uint32 d = *dstp;	*dstp++ = (((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1)	+ (s & d & 0x00010101);	i--;	}	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm1" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("paddd" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("psrld" " %0, %%" "mm5" : : "X" (   1  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("paddd" " %" "mm5" ", %" "mm2")  ;	__asm__ __volatile__ ("movq" " %%" "mm2" ", %0" : "=X" (    (*dstp)  ) :   )  ;	dstp += 2;	srcp += 2;	i--;	}	__asm__ __volatile__ ("emms") ;	} while(0) ;	}	nocopy4ALPHA_BLIT32_888_50MMX :	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  4 ;	for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy4ALPHA_BLIT32_888_50 ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i;	Uint32 *src = (Uint32 *)(  srcbuf + start *  4  );	Uint32 *dst = (Uint32 *)( dstbuf + startcol *  4  );	for(i = 0; i < (int)(  len ); i++) {	Uint32 s = *src++;	Uint32 d = *dst;	*dst++ = (((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1)	+ (s & d & 0x00010101);	}	} while(0) ;	}	nocopy4ALPHA_BLIT32_888_50 :	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	else	{	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  4 ;	for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy4ALPHA_BLIT32_888MMX ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	Uint32 *srcp = (Uint32 *)(  srcbuf + start *  4  );	Uint32 *dstp = (Uint32 *)( dstbuf + startcol *  4  );	int i = 0x00FF00FF;	__asm__ __volatile__ ("movd" " %0, %%" "mm3" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm3" ", %" "mm3")  ;	i = 0xFF000000;	__asm__ __volatile__ ("movd" " %0, %%" "mm7" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm7" ", %" "mm7")  ;	i =   alpha  |   alpha  << 16;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm4" ", %" "mm4")  ;	i =   len ;	if(i & 1) {	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   (*srcp)  ))  ; __asm__ __volatile__ ("punpcklbw" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm1")  ;	__asm__ __volatile__ ("movd" " %0, %%" "mm2" : : "X" (   (*dstp)  ))  ; __asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm0")  ; __asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm0")  ; __asm__ __volatile__ ("punpcklbw" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("psubw" " %" "mm2" ", %" "mm1")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm1")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm1" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm1" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("packuswb" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pcmpeqd" " %" "mm1" ", %" "mm1")  ; __asm__ __volatile__ ("pxor" " %" "mm7" ", %" "mm1")  ; __asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm2")  ; __asm__ __volatile__ ("por" " %" "mm0" ", %" "mm2")  ;	__asm__ __volatile__ ("movd" " %%" "mm2" ", %0" : "=X" (    *dstp  ) :   )  ;	++srcp;	++dstp;	i--;	}	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm0" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm0" ", %" "mm1")  ;	__asm__ __volatile__ ("punpcklbw" " %" "mm0" ", %" "mm0")  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("punpckhbw" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm0")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("punpcklbw" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm1")  ;	__asm__ __volatile__ ("punpckhbw" " %" "mm6" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("psubw" " %" "mm2" ", %" "mm0")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm0")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm1")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm1")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm0" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm0" ", %" "mm2")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm1" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("packuswb" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pcmpeqd" " %" "mm1" ", %" "mm1")  ; __asm__ __volatile__ ("packuswb" " %" "mm6" ", %" "mm6")  ;	__asm__ __volatile__ ("pxor" " %" "mm7" ", %" "mm1")  ; __asm__ __volatile__ ("psrlq" " %0, %%" "mm2" : : "X" (   32  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm2")  ; __asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   32  ) )  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm2")  ;	__asm__ __volatile__ ("por" " %" "mm5" ", %" "mm2")  ;	__asm__ __volatile__ ("movq" " %%" "mm2" ", %0" : "=X" (    *dstp  ) :   )  ;	srcp += 2;	dstp += 2;	i--;	}	__asm__ __volatile__ ("emms") ;	} while(0) ;	}	nocopy4ALPHA_BLIT32_888MMX :	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  4 ;	for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy4ALPHA_BLIT32_888 ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i = 0;	Uint32 *src = (Uint32 *)(  srcbuf + start *  4  );	Uint32 *dst = (Uint32 *)( dstbuf + startcol *  4  );	if(((int)(  len )) & 0x01) {	Uint32 s = *src++;	Uint32 d = *dst;	Uint32 s1 = s & 0xff00ff;	Uint32 d1 = d & 0xff00ff;	d1 = (d1 + ((s1 - d1) *   alpha  >> 8)) & 0xff00ff;	s &= 0xff00;	d &= 0xff00;	d = (d + ((s - d) *   alpha  >> 8)) & 0xff00;	*dst++ = d1 | d;	i++;	}	for(; i < (int)(  len ); i+=2) {	Uint32 s = *src++;	Uint32 d = *dst;	Uint32 s1 = s & 0xff00ff;	Uint32 d1 = d & 0xff00ff;	d1 = (d1 + ((s1 - d1) *   alpha  >> 8)) & 0xff00ff;	s1 = *src++;	s = ((s & 0xff00) >> 8) | ((s1 & 0xff00) << 8);	d = ((d & 0xff00) >> 8) | ((dst[1] & 0xff00) << 8);	d = (d + ((s - d) *   alpha  >> 8)) & 0xff00ff;	*dst++ = d1 | ((d & 0xff) << 8);	s1 &= 0xff00ff;	d1 = *dst;	d1 &= 0xff00ff;	d1 = (d1 + ((s1 - d1) *   alpha  >> 8)) & 0xff00ff;	*dst++ = d1 | ((d & 0xff) >> 8);	}	} while(0) ;	}	nocopy4ALPHA_BLIT32_888 :	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	} else	 do {	int linecount = srcrect->h;	int ofs = 0;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left *  4 ;	for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	if(ofs < right) {	int start = 0;	int len = run;	int startcol;	if(left - ofs > 0) {	start = left - ofs;	len -= start;	if(len <= 0)	goto nocopy4ALPHA_BLIT_ANY ;	}	startcol = ofs + start;	if(len > right - startcol)	len = right - startcol;	  do {	int i;	Uint8 *src =   srcbuf + start *  4  ;	Uint8 *dst =  dstbuf + startcol *  4  ;	for(i = 0; i < (int)(  len ); i++) {	Uint32 s, d;	unsigned rs, gs, bs, rd, gd, bd;	switch(   4  ) {	case 2:	s = *(Uint16 *)src;	d = *(Uint16 *)dst;	break;	case 3:	if(1234   == 4321 ) {	s = (src[0] << 16) | (src[1] << 8) | src[2];	d = (dst[0] << 16) | (dst[1] << 8) | dst[2];	} else {	s = (src[2] << 16) | (src[1] << 8) | src[0];	d = (dst[2] << 16) | (dst[1] << 8) | dst[0];	}	break;	case 4:	s = *(Uint32 *)src;	d = *(Uint32 *)dst;	break;	}	{	  rs  = ((( s &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gs  = ((( s &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bs  = ((( s &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	{	  rd  = ((( d &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gd  = ((( d &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bd  = ((( d &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	rd += (rs - rd) *   alpha  >> 8;	gd += (gs - gd) *   alpha  >> 8;	bd += (bs - bd) *   alpha  >> 8;	{	 d  = ((  rd >>  fmt ->Rloss)<<  fmt ->Rshift)|	((  gd >>  fmt ->Gloss)<<  fmt ->Gshift)|	((  bd >>  fmt ->Bloss)<<  fmt ->Bshift);	} ;	switch(   4  ) {	case 2:	*(Uint16 *)dst = d;	break;	case 3:	if(1234   == 4321 ) {	dst[0] = d >> 16;	dst[1] = d >> 8;	dst[2] = d;	} else {	dst[0] = d;	dst[1] = d >> 8;	dst[2] = d >> 16;	}	break;	case 4:	*(Uint32 *)dst = d;	break;	}	src +=    4  ;	dst +=    4  ;	}	} while(0) ;	}	nocopy4ALPHA_BLIT_ANY :	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	break;	}	}	} while(0) ;



}


 
int SDL_RLEBlit(SDL_Surface *src, SDL_Rect *srcrect,
		SDL_Surface *dst, SDL_Rect *dstrect)
{
	Uint8 *dstbuf;
	Uint8 *srcbuf;
	int x, y;
	int w = src->w;
	unsigned alpha;

	 
	if ( ( dst ->offset ||	(( dst ->flags & (0x00000001 | 0x00000004 | 0x00004000 )) != 0))  ) {
		if ( SDL_LockSurface(dst) < 0 ) {
			return(-1);
		}
	}

	 
	x = dstrect->x;
	y = dstrect->y;
	dstbuf = (Uint8 *)dst->pixels
	         + y * dst->pitch + x * src->format->BytesPerPixel;
	srcbuf = (Uint8 *)src->map->sw_data->aux_data;

	{
	     
	    int vskip = srcrect->y;
	    int ofs = 0;
	    if(vskip) {


//#923 "SDL_RLEaccel.c"

		switch(src->format->BytesPerPixel) {
		case 1: for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += sizeof(  Uint8 ) * 2;	if(run) {	srcbuf += run *  1 ;	ofs += run;	} else if(!ofs)	goto done;	if(ofs == w) {	ofs = 0;	if(!--vskip)	break;	}	} ; break;
		case 2: for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += sizeof(  Uint8 ) * 2;	if(run) {	srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	goto done;	if(ofs == w) {	ofs = 0;	if(!--vskip)	break;	}	} ; break;
		case 3: for(;;) {	int run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += sizeof(  Uint8 ) * 2;	if(run) {	srcbuf += run *  3 ;	ofs += run;	} else if(!ofs)	goto done;	if(ofs == w) {	ofs = 0;	if(!--vskip)	break;	}	} ; break;
		case 4: for(;;) {	int run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += sizeof(  Uint16 ) * 2;	if(run) {	srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	goto done;	if(ofs == w) {	ofs = 0;	if(!--vskip)	break;	}	} ; break;
		}



	    }
	}

	alpha = (src->flags & 0x00010000 ) == 0x00010000 
	        ? src->format->alpha : 255;
	 
	if ( srcrect->x || srcrect->w != src->w ) {
	    RLEClipBlit(w, srcbuf, dst, dstbuf, srcrect, alpha);
	} else {
	    SDL_PixelFormat *fmt = src->format;


//#967 "SDL_RLEaccel.c"

	    do {	if(  alpha  == 255) {	switch(  fmt ->BytesPerPixel) {	case 1:  do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	if(     1    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    run  ) )), "1" (   dstbuf + ofs *  1    ), "2" (      srcbuf   )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    run  ) * (     1   ) )/4), "q" (  (unsigned)(    run  ) * (     1   ) ), "1" (   dstbuf + ofs *  1    ),"2" (      srcbuf   ) : "memory" );	} while(0) ;	}	} while(0)  ; srcbuf += run *  1 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	case 2:  do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	if(     2    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    run  ) )), "1" (   dstbuf + ofs *  2    ), "2" (      srcbuf   )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    run  ) * (     2   ) )/4), "q" (  (unsigned)(    run  ) * (     2   ) ), "1" (   dstbuf + ofs *  2    ),"2" (      srcbuf   ) : "memory" );	} while(0) ;	}	} while(0)  ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	case 3:  do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	if(     3    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    run  ) )), "1" (   dstbuf + ofs *  3    ), "2" (      srcbuf   )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    run  ) * (     3   ) )/4), "q" (  (unsigned)(    run  ) * (     3   ) ), "1" (   dstbuf + ofs *  3    ),"2" (      srcbuf   ) : "memory" );	} while(0) ;	}	} while(0)  ; srcbuf += run *  3 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	case 4:  do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	  do {	if(     4    == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(    run  ) )), "1" (   dstbuf + ofs *  4    ), "2" (      srcbuf   )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(    run  ) * (     4   ) )/4), "q" (  (unsigned)(    run  ) * (     4   ) ), "1" (   dstbuf + ofs *  4    ),"2" (      srcbuf   ) : "memory" );	} while(0) ;	}	} while(0)  ; srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ; break;	}	} else {	switch(  fmt ->BytesPerPixel) {	case 1:	break;	case 2:	switch(  fmt ->Rmask |   fmt ->Gmask |   fmt ->Bmask) {	case 0xffff:	if(  fmt ->Gmask == 0x07e0	||   fmt ->Rmask == 0x07e0	||   fmt ->Bmask == 0x07e0) {	if(  alpha  == 128)	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	unsigned n = (    run  );	Uint16 *src = (Uint16 *)(    srcbuf  );	Uint16 *dst = (Uint16 *)(  dstbuf + ofs *  2   );	if(((unsigned long)src ^ (unsigned long)dst) & 3) {	while(n--)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xf7de  ) + (d &     0xf7de  )) >> 1)	+ (s & d & (~    0xf7de   & 0xffff));	} while(0) ;	} else {	if((unsigned long)src & 3) {	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xf7de  ) + (d &     0xf7de  )) >> 1)	+ (s & d & (~    0xf7de   & 0xffff));	} while(0) ;	n--;	}	for(; n > 1; n -= 2) {	Uint32 s = *(Uint32 *)src;	Uint32 d = *(Uint32 *)dst;	*(Uint32 *)dst = ((s & (  0xf7de  |   0xf7de  << 16)) >> 1)	+ ((d & (  0xf7de  |   0xf7de  << 16)) >> 1)	+ (s & d & (~(  0xf7de  |   0xf7de  << 16)));	src += 2;	dst += 2;	}	if(n)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xf7de  ) + (d &     0xf7de  )) >> 1)	+ (s & d & (~    0xf7de   & 0xffff));	} while(0) ; }	} while(0)  ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else {	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	int i, n = 0;	Uint16 *srcp = (Uint16 *)(  srcbuf );	Uint16 *dstp = (Uint16 *)( dstbuf + ofs *  2  );	Uint32 ALPHA = 0xF800;	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	ALPHA = 0x07E0;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	ALPHA = 0x001F;	__asm__ __volatile__ ("movd" " %0, %%" "mm7" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	i = (Uint32)  alpha  | (Uint32)  alpha  << 16;	__asm__ __volatile__ ("movd" " %0, %%" "mm0" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm0" ", %" "mm0")  ;	ALPHA =   alpha  >> 3;	i = ((int)(  run ) & 3);	for(; i > 0; --i) {	Uint32 s = *srcp++;	Uint32 d = *dstp;	s = (s | s << 16) & 0x07e0f81f;	d = (d | d << 16) & 0x07e0f81f;	d += (s - d) * ALPHA >> 5;	d &= 0x07e0f81f;	*dstp++ = d | d >> 16;	n++;	}	i = (int)(  run ) - n;	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm3" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   11  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   11  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   11  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %%" "mm3" ", %0" : "=X" (    *dstp  ) :   )  ;	srcp += 4;	dstp += 4;	i -= 3;	}	__asm__ __volatile__ ("emms") ;	} while(0) ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	int i;	Uint16 *src = (Uint16 *)(  srcbuf );	Uint16 *dst = (Uint16 *)( dstbuf + ofs *  2  );	Uint32 ALPHA =   alpha  >> 3;	for(i = 0; i < (int)(  run ); i++) {	Uint32 s = *src++;	Uint32 d = *dst;	s = (s | s << 16) & 0x07e0f81f;	d = (d | d << 16) & 0x07e0f81f;	d += (s - d) * ALPHA >> 5;	d &= 0x07e0f81f;	*dst++ = d | d >> 16;	}	} while(0) ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	} else	goto general16;	break;	case 0x7fff:	if(  fmt ->Gmask == 0x03e0	||   fmt ->Rmask == 0x03e0	||   fmt ->Bmask == 0x03e0) {	if(  alpha  == 128)	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	unsigned n = (    run  );	Uint16 *src = (Uint16 *)(    srcbuf  );	Uint16 *dst = (Uint16 *)(  dstbuf + ofs *  2   );	if(((unsigned long)src ^ (unsigned long)dst) & 3) {	while(n--)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xfbde  ) + (d &     0xfbde  )) >> 1)	+ (s & d & (~    0xfbde   & 0xffff));	} while(0) ;	} else {	if((unsigned long)src & 3) {	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xfbde  ) + (d &     0xfbde  )) >> 1)	+ (s & d & (~    0xfbde   & 0xffff));	} while(0) ;	n--;	}	for(; n > 1; n -= 2) {	Uint32 s = *(Uint32 *)src;	Uint32 d = *(Uint32 *)dst;	*(Uint32 *)dst = ((s & (  0xfbde  |   0xfbde  << 16)) >> 1)	+ ((d & (  0xfbde  |   0xfbde  << 16)) >> 1)	+ (s & d & (~(  0xfbde  |   0xfbde  << 16)));	src += 2;	dst += 2;	}	if(n)	do {	Uint32 s = *  src ++;	Uint32 d = * dst ;	* dst ++ = (((s &     0xfbde  ) + (d &     0xfbde  )) >> 1)	+ (s & d & (~    0xfbde   & 0xffff));	} while(0) ; }	} while(0)  ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else {	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	int i, n = 0;	Uint16 *srcp = (Uint16 *)(  srcbuf );	Uint16 *dstp = (Uint16 *)( dstbuf + ofs *  2  );	Uint32 ALPHA = 0x7C00;	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm1" ", %" "mm1")  ;	ALPHA = 0x03E0;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm4" ", %" "mm4")  ;	ALPHA = 0x001F;	__asm__ __volatile__ ("movd" " %0, %%" "mm7" : : "X" (   *(&ALPHA)  ))  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	__asm__ __volatile__ ("punpcklwd" " %" "mm7" ", %" "mm7")  ;	i = (Uint32)  alpha  | (Uint32)  alpha  << 16;	__asm__ __volatile__ ("movd" " %0, %%" "mm0" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm0" ", %" "mm0")  ;	i = ((int)(  run ) & 3);	ALPHA =   alpha  >> 3;	for(; i > 0; --i) {	Uint32 s = *srcp++;	Uint32 d = *dstp;	s = (s | s << 16) & 0x03e07c1f;	d = (d | d << 16) & 0x03e07c1f;	d += (s - d) * ALPHA >> 5;	d &= 0x03e07c1f;	*dstp++ = d | d >> 16;	n++;	}	i = (int)(  run ) - n;	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm3" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   10  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   10  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   10  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm5" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("psrlq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   5  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("movq" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("pmullw" " %" "mm0" ", %" "mm5")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm5" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm5" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("por" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm5" ", %" "mm3")  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm3")  ;	__asm__ __volatile__ ("movq" " %%" "mm3" ", %0" : "=X" (    *dstp  ) :   )  ;	srcp += 4;	dstp += 4;	i -= 3;	}	__asm__ __volatile__ ("emms") ;	} while(0) ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	int i;	Uint16 *src = (Uint16 *)(  srcbuf );	Uint16 *dst = (Uint16 *)( dstbuf + ofs *  2  );	Uint32 ALPHA =   alpha  >> 3;	for(i = 0; i < (int)(  run ); i++) {	Uint32 s = *src++;	Uint32 d = *dst;	s = (s | s << 16) & 0x03e07c1f;	d = (d | d << 16) & 0x03e07c1f;	d += (s - d) * ALPHA >> 5;	d &= 0x03e07c1f;	*dst++ = d | d >> 16;	}	} while(0) ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	break;	}	default:	general16:	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	int i;	Uint8 *src =   srcbuf ;	Uint8 *dst =  dstbuf + ofs *  2  ;	for(i = 0; i < (int)(  run ); i++) {	Uint32 s, d;	unsigned rs, gs, bs, rd, gd, bd;	switch(   2  ) {	case 2:	s = *(Uint16 *)src;	d = *(Uint16 *)dst;	break;	case 3:	if(1234   == 4321 ) {	s = (src[0] << 16) | (src[1] << 8) | src[2];	d = (dst[0] << 16) | (dst[1] << 8) | dst[2];	} else {	s = (src[2] << 16) | (src[1] << 8) | src[0];	d = (dst[2] << 16) | (dst[1] << 8) | dst[0];	}	break;	case 4:	s = *(Uint32 *)src;	d = *(Uint32 *)dst;	break;	}	{	  rs  = ((( s &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gs  = ((( s &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bs  = ((( s &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	{	  rd  = ((( d &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gd  = ((( d &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bd  = ((( d &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	rd += (rs - rd) *   alpha  >> 8;	gd += (gs - gd) *   alpha  >> 8;	bd += (bs - bd) *   alpha  >> 8;	{	 d  = ((  rd >>  fmt ->Rloss)<<  fmt ->Rshift)|	((  gd >>  fmt ->Gloss)<<  fmt ->Gshift)|	((  bd >>  fmt ->Bloss)<<  fmt ->Bshift);	} ;	switch(   2  ) {	case 2:	*(Uint16 *)dst = d;	break;	case 3:	if(1234   == 4321 ) {	dst[0] = d >> 16;	dst[1] = d >> 8;	dst[2] = d;	} else {	dst[0] = d;	dst[1] = d >> 8;	dst[2] = d >> 16;	}	break;	case 4:	*(Uint32 *)dst = d;	break;	}	src +=    2  ;	dst +=    2  ;	}	} while(0) ; srcbuf += run *  2 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	break;	case 3:	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint8  *)srcbuf;	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	  do {	int i;	Uint8 *src =   srcbuf ;	Uint8 *dst =  dstbuf + ofs *  3  ;	for(i = 0; i < (int)(  run ); i++) {	Uint32 s, d;	unsigned rs, gs, bs, rd, gd, bd;	switch(   3  ) {	case 2:	s = *(Uint16 *)src;	d = *(Uint16 *)dst;	break;	case 3:	if(1234   == 4321 ) {	s = (src[0] << 16) | (src[1] << 8) | src[2];	d = (dst[0] << 16) | (dst[1] << 8) | dst[2];	} else {	s = (src[2] << 16) | (src[1] << 8) | src[0];	d = (dst[2] << 16) | (dst[1] << 8) | dst[0];	}	break;	case 4:	s = *(Uint32 *)src;	d = *(Uint32 *)dst;	break;	}	{	  rs  = ((( s &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gs  = ((( s &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bs  = ((( s &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	{	  rd  = ((( d &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gd  = ((( d &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bd  = ((( d &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	rd += (rs - rd) *   alpha  >> 8;	gd += (gs - gd) *   alpha  >> 8;	bd += (bs - bd) *   alpha  >> 8;	{	 d  = ((  rd >>  fmt ->Rloss)<<  fmt ->Rshift)|	((  gd >>  fmt ->Gloss)<<  fmt ->Gshift)|	((  bd >>  fmt ->Bloss)<<  fmt ->Bshift);	} ;	switch(   3  ) {	case 2:	*(Uint16 *)dst = d;	break;	case 3:	if(1234   == 4321 ) {	dst[0] = d >> 16;	dst[1] = d >> 8;	dst[2] = d;	} else {	dst[0] = d;	dst[1] = d >> 8;	dst[2] = d >> 16;	}	break;	case 4:	*(Uint32 *)dst = d;	break;	}	src +=    3  ;	dst +=    3  ;	}	} while(0) ; srcbuf += run *  3 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	break;	case 4:	if((  fmt ->Rmask |   fmt ->Gmask |   fmt ->Bmask) == 0x00ffffff	&& (  fmt ->Gmask == 0xff00 ||   fmt ->Rmask == 0xff00	||   fmt ->Bmask == 0xff00)) {	if(  alpha  == 128)	{	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	  do {	Uint32 *srcp = (Uint32 *)(  srcbuf );	Uint32 *dstp = (Uint32 *)( dstbuf + ofs *  4  );	int i = 0x00fefefe;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm4" ", %" "mm4")  ;	i = 0x00010101;	__asm__ __volatile__ ("movd" " %0, %%" "mm3" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm3" ", %" "mm3")  ;	i = (int)(  run );	if( i & 1 ) {	Uint32 s = *srcp++;	Uint32 d = *dstp;	*dstp++ = (((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1)	+ (s & d & 0x00010101);	i--;	}	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm6")  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm1" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm1" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm4" ", %" "mm5")  ;	__asm__ __volatile__ ("paddd" " %" "mm6" ", %" "mm5")  ;	__asm__ __volatile__ ("psrld" " %0, %%" "mm5" : : "X" (   1  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("paddd" " %" "mm5" ", %" "mm2")  ;	__asm__ __volatile__ ("movq" " %%" "mm2" ", %0" : "=X" (    (*dstp)  ) :   )  ;	dstp += 2;	srcp += 2;	i--;	}	__asm__ __volatile__ ("emms") ;	} while(0) ; srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	  do {	int i;	Uint32 *src = (Uint32 *)(  srcbuf );	Uint32 *dst = (Uint32 *)( dstbuf + ofs *  4  );	for(i = 0; i < (int)(  run ); i++) {	Uint32 s = *src++;	Uint32 d = *dst;	*dst++ = (((s & 0x00fefefe) + (d & 0x00fefefe)) >> 1)	+ (s & d & 0x00010101);	}	} while(0) ; srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	else	{	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	  do {	Uint32 *srcp = (Uint32 *)(  srcbuf );	Uint32 *dstp = (Uint32 *)( dstbuf + ofs *  4  );	int i = 0x00FF00FF;	__asm__ __volatile__ ("movd" " %0, %%" "mm3" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm3" ", %" "mm3")  ;	i = 0xFF000000;	__asm__ __volatile__ ("movd" " %0, %%" "mm7" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm7" ", %" "mm7")  ;	i =   alpha  |   alpha  << 16;	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&i)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm4" ", %" "mm4")  ;	i =   run ;	if(i & 1) {	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   (*srcp)  ))  ; __asm__ __volatile__ ("punpcklbw" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm1")  ;	__asm__ __volatile__ ("movd" " %0, %%" "mm2" : : "X" (   (*dstp)  ))  ; __asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm0")  ; __asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm0")  ; __asm__ __volatile__ ("punpcklbw" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("psubw" " %" "mm2" ", %" "mm1")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm1")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm1" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm1" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("packuswb" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pcmpeqd" " %" "mm1" ", %" "mm1")  ; __asm__ __volatile__ ("pxor" " %" "mm7" ", %" "mm1")  ; __asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm2")  ; __asm__ __volatile__ ("por" " %" "mm0" ", %" "mm2")  ;	__asm__ __volatile__ ("movd" " %%" "mm2" ", %0" : "=X" (    *dstp  ) :   )  ;	++srcp;	++dstp;	i--;	}	for(; i > 0; --i) {	__asm__ __volatile__ ("movq" " %0, %%" "mm0" : : "X" (   (*srcp)  ))  ;	__asm__ __volatile__ ("movq" " %" "mm0" ", %" "mm1")  ;	__asm__ __volatile__ ("punpcklbw" " %" "mm0" ", %" "mm0")  ;	__asm__ __volatile__ ("movq" " %0, %%" "mm2" : : "X" (   (*dstp)  ))  ;	__asm__ __volatile__ ("punpckhbw" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm0")  ;	__asm__ __volatile__ ("movq" " %" "mm2" ", %" "mm5")  ;	__asm__ __volatile__ ("punpcklbw" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm7" ", %" "mm5")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm1")  ;	__asm__ __volatile__ ("punpckhbw" " %" "mm6" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("psubw" " %" "mm2" ", %" "mm0")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm0")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("psubw" " %" "mm6" ", %" "mm1")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm1")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm0" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm0" ", %" "mm2")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm1" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm1" ", %" "mm6")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm6")  ;	__asm__ __volatile__ ("packuswb" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pcmpeqd" " %" "mm1" ", %" "mm1")  ; __asm__ __volatile__ ("packuswb" " %" "mm6" ", %" "mm6")  ;	__asm__ __volatile__ ("pxor" " %" "mm7" ", %" "mm1")  ; __asm__ __volatile__ ("psrlq" " %0, %%" "mm2" : : "X" (   32  ) )  ;	__asm__ __volatile__ ("pand" " %" "mm1" ", %" "mm2")  ; __asm__ __volatile__ ("psllq" " %0, %%" "mm6" : : "X" (   32  ) )  ;	__asm__ __volatile__ ("por" " %" "mm6" ", %" "mm2")  ;	__asm__ __volatile__ ("por" " %" "mm5" ", %" "mm2")  ;	__asm__ __volatile__ ("movq" " %%" "mm2" ", %0" : "=X" (    *dstp  ) :   )  ;	srcp += 2;	dstp += 2;	i--;	}	__asm__ __volatile__ ("emms") ;	} while(0) ; srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	else	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	  do {	int i = 0;	Uint32 *src = (Uint32 *)(  srcbuf );	Uint32 *dst = (Uint32 *)( dstbuf + ofs *  4  );	if(((int)(  run )) & 0x01) {	Uint32 s = *src++;	Uint32 d = *dst;	Uint32 s1 = s & 0xff00ff;	Uint32 d1 = d & 0xff00ff;	d1 = (d1 + ((s1 - d1) *   alpha  >> 8)) & 0xff00ff;	s &= 0xff00;	d &= 0xff00;	d = (d + ((s - d) *   alpha  >> 8)) & 0xff00;	*dst++ = d1 | d;	i++;	}	for(; i < (int)(  run ); i+=2) {	Uint32 s = *src++;	Uint32 d = *dst;	Uint32 s1 = s & 0xff00ff;	Uint32 d1 = d & 0xff00ff;	d1 = (d1 + ((s1 - d1) *   alpha  >> 8)) & 0xff00ff;	s1 = *src++;	s = ((s & 0xff00) >> 8) | ((s1 & 0xff00) << 8);	d = ((d & 0xff00) >> 8) | ((dst[1] & 0xff00) << 8);	d = (d + ((s - d) *   alpha  >> 8)) & 0xff00ff;	*dst++ = d1 | ((d & 0xff) << 8);	s1 &= 0xff00ff;	d1 = *dst;	d1 &= 0xff00ff;	d1 = (d1 + ((s1 - d1) *   alpha  >> 8)) & 0xff00ff;	*dst++ = d1 | ((d & 0xff) >> 8);	}	} while(0) ; srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	}	} else	 do {	int linecount = srcrect->h;	int ofs = 0;	for(;;) {	unsigned run;	ofs += *(  Uint16  *)srcbuf;	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	  do {	int i;	Uint8 *src =   srcbuf ;	Uint8 *dst =  dstbuf + ofs *  4  ;	for(i = 0; i < (int)(  run ); i++) {	Uint32 s, d;	unsigned rs, gs, bs, rd, gd, bd;	switch(   4  ) {	case 2:	s = *(Uint16 *)src;	d = *(Uint16 *)dst;	break;	case 3:	if(1234   == 4321 ) {	s = (src[0] << 16) | (src[1] << 8) | src[2];	d = (dst[0] << 16) | (dst[1] << 8) | dst[2];	} else {	s = (src[2] << 16) | (src[1] << 8) | src[0];	d = (dst[2] << 16) | (dst[1] << 8) | dst[0];	}	break;	case 4:	s = *(Uint32 *)src;	d = *(Uint32 *)dst;	break;	}	{	  rs  = ((( s &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gs  = ((( s &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bs  = ((( s &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	{	  rd  = ((( d &  fmt ->Rmask)>>  fmt ->Rshift)<<  fmt ->Rloss);   gd  = ((( d &  fmt ->Gmask)>>  fmt ->Gshift)<<  fmt ->Gloss);   bd  = ((( d &  fmt ->Bmask)>>  fmt ->Bshift)<<  fmt ->Bloss); } ;	rd += (rs - rd) *   alpha  >> 8;	gd += (gs - gd) *   alpha  >> 8;	bd += (bs - bd) *   alpha  >> 8;	{	 d  = ((  rd >>  fmt ->Rloss)<<  fmt ->Rshift)|	((  gd >>  fmt ->Gloss)<<  fmt ->Gshift)|	((  bd >>  fmt ->Bloss)<<  fmt ->Bshift);	} ;	switch(   4  ) {	case 2:	*(Uint16 *)dst = d;	break;	case 3:	if(1234   == 4321 ) {	dst[0] = d >> 16;	dst[1] = d >> 8;	dst[2] = d;	} else {	dst[0] = d;	dst[1] = d >> 8;	dst[2] = d >> 16;	}	break;	case 4:	*(Uint32 *)dst = d;	break;	}	src +=    4  ;	dst +=    4  ;	}	} while(0) ; srcbuf += run *  4 ;	ofs += run;	} else if(!ofs)	break;	if(ofs == w) {	ofs = 0;	dstbuf += dst->pitch;	if(!--linecount)	break;	}	}	} while(0) ;	break;	}	}	} while(0) ;


	}

done:
	 
	if ( ( dst ->offset ||	(( dst ->flags & (0x00000001 | 0x00000004 | 0x00004000 )) != 0))  ) {
		SDL_UnlockSurface(dst);
	}
	return(0);
}



 





	

//#1014 "SDL_RLEaccel.c"



 




//#1034 "SDL_RLEaccel.c"

 




//#1050 "SDL_RLEaccel.c"


//#1062 "SDL_RLEaccel.c"

 

typedef struct {
    	Uint8  BytesPerPixel;
	Uint8  Rloss;
	Uint8  Gloss;
	Uint8  Bloss;
	Uint8  Rshift;
	Uint8  Gshift;
	Uint8  Bshift;
	Uint8  Ashift;
	Uint32 Rmask;
	Uint32 Gmask;
	Uint32 Bmask;
	Uint32 Amask;
} RLEDestFormat;

 
static void RLEAlphaClipBlit(int w, Uint8 *srcbuf, SDL_Surface *dst,
			     Uint8 *dstbuf, SDL_Rect *srcrect)
{
    SDL_PixelFormat *df = dst->format;
     





//#1157 "SDL_RLEaccel.c"

    switch(df->BytesPerPixel) {
    case 2:
	if(df->Gmask == 0x07e0 || df->Rmask == 0x07e0
	   || df->Bmask == 0x07e0)
	    do {	int linecount = srcrect->h;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left * sizeof( Uint16 );	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint8  *)srcbuf)[0];	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0)	do {	if(  sizeof( Uint16 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) )), "1" (  dstbuf + cofs * sizeof( Uint16 )  ), "2" (   	srcbuf + (cofs - ofs) * sizeof( Uint16 )  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint16 ) ) )/4), "q" (  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint16 ) ) ), "1" (  dstbuf + cofs * sizeof( Uint16 )  ),"2" (   	srcbuf + (cofs - ofs) * sizeof( Uint16 )  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint16 );	ofs += run;	} else if(!ofs)	return;	} while(ofs < w);	if(sizeof( Uint16 ) == 2)	srcbuf += (unsigned long)srcbuf & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0) {	 Uint16  *dst = ( Uint16  *)dstbuf + cofs;	Uint32 *src = (Uint32 *)srcbuf + (cofs - ofs);	int i;	for(i = 0; i < crun; i++)	  do {	Uint32 s =  src[i] ;	Uint32 d =   dst[i] ;	unsigned alpha = (s & 0x3e0) >> 5;	s &= 0x07e0f81f;	d = (d | d << 16) & 0x07e0f81f;	d += (s - d) * alpha >> 5;	d &= 0x07e0f81f;	  dst[i]  = d | d >> 16;	} while(0) ;	}	srcbuf += run * 4;	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	else
	    do {	int linecount = srcrect->h;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left * sizeof( Uint16 );	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint8  *)srcbuf)[0];	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0)	do {	if(  sizeof( Uint16 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) )), "1" (  dstbuf + cofs * sizeof( Uint16 )  ), "2" (   	srcbuf + (cofs - ofs) * sizeof( Uint16 )  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint16 ) ) )/4), "q" (  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint16 ) ) ), "1" (  dstbuf + cofs * sizeof( Uint16 )  ),"2" (   	srcbuf + (cofs - ofs) * sizeof( Uint16 )  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint16 );	ofs += run;	} else if(!ofs)	return;	} while(ofs < w);	if(sizeof( Uint16 ) == 2)	srcbuf += (unsigned long)srcbuf & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0) {	 Uint16  *dst = ( Uint16  *)dstbuf + cofs;	Uint32 *src = (Uint32 *)srcbuf + (cofs - ofs);	int i;	for(i = 0; i < crun; i++)	  do {	Uint32 s =  src[i] ;	Uint32 d =   dst[i] ;	unsigned alpha = (s & 0x3e0) >> 5;	s &= 0x03e07c1f;	d = (d | d << 16) & 0x03e07c1f;	d += (s - d) * alpha >> 5;	d &= 0x03e07c1f;	  dst[i]  = d | d >> 16;	} while(0) ;	}	srcbuf += run * 4;	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	break;
    case 4:

	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )
	    do {	int linecount = srcrect->h;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left * sizeof( Uint32 );	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint16  *)srcbuf)[0];	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0)	do {	if(  sizeof( Uint32 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) )), "1" (  dstbuf + cofs * sizeof( Uint32 )  ), "2" (   	srcbuf + (cofs - ofs) * sizeof( Uint32 )  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint32 ) ) )/4), "q" (  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint32 ) ) ), "1" (  dstbuf + cofs * sizeof( Uint32 )  ),"2" (   	srcbuf + (cofs - ofs) * sizeof( Uint32 )  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint32 );	ofs += run;	} else if(!ofs)	return;	} while(ofs < w);	if(sizeof( Uint32 ) == 2)	srcbuf += (unsigned long)srcbuf & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0) {	 Uint32  *dst = ( Uint32  *)dstbuf + cofs;	Uint32 *src = (Uint32 *)srcbuf + (cofs - ofs);	int i;	for(i = 0; i < crun; i++)	  do {	int __tmp = 0x00FF00FF;	__asm__ __volatile__ ("movd" " %0, %%" "mm3" : : "X" (   *(&__tmp)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm3" ", %" "mm3")  ;	__tmp = (Uint32) src[i]  >> 24;	__tmp |= (__tmp << 16);	__asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&__tmp)  ))  ;	__asm__ __volatile__ ("punpckldq" " %" "mm4" ", %" "mm4")  ;	__asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   *(&(Uint32) src[i] )  ))  ;	__asm__ __volatile__ ("punpcklbw" " %" "mm1" ", %" "mm1")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm1")  ;	__asm__ __volatile__ ("movd" " %0, %%" "mm2" : : "X" (   *(&(Uint32)  dst[i] )  ))  ;	__asm__ __volatile__ ("punpcklbw" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("psubw" " %" "mm2" ", %" "mm1")  ;	__asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm1")  ;	__asm__ __volatile__ ("psrlw" " %0, %%" "mm1" : : "X" (   8  ) )  ;	__asm__ __volatile__ ("paddw" " %" "mm1" ", %" "mm2")  ;	__asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;	__asm__ __volatile__ ("packuswb" " %" "mm2" ", %" "mm2")  ;	__asm__ __volatile__ ("movd" " %%" "mm2" ", %0" : "=X" (    *(&(Uint32)  dst[i] )  ) :   )  ;	__asm__ __volatile__ ("emms") ;	} while(0) ;	}	srcbuf += run * 4;	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	else

	    do {	int linecount = srcrect->h;	int left = srcrect->x;	int right = left + srcrect->w;	dstbuf -= left * sizeof( Uint32 );	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint16  *)srcbuf)[0];	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0)	do {	if(  sizeof( Uint32 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) )), "1" (  dstbuf + cofs * sizeof( Uint32 )  ), "2" (   	srcbuf + (cofs - ofs) * sizeof( Uint32 )  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint32 ) ) )/4), "q" (  (unsigned)(  (unsigned)crun ) * (  sizeof( Uint32 ) ) ), "1" (  dstbuf + cofs * sizeof( Uint32 )  ),"2" (   	srcbuf + (cofs - ofs) * sizeof( Uint32 )  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint32 );	ofs += run;	} else if(!ofs)	return;	} while(ofs < w);	if(sizeof( Uint32 ) == 2)	srcbuf += (unsigned long)srcbuf & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	int cofs = ofs;	int crun = run;	if(left - cofs > 0) {	crun -= left - cofs;	cofs = left;	}	if(crun > right - cofs)	crun = right - cofs;	if(crun > 0) {	 Uint32  *dst = ( Uint32  *)dstbuf + cofs;	Uint32 *src = (Uint32 *)srcbuf + (cofs - ofs);	int i;	for(i = 0; i < crun; i++)	  do {	Uint32 s =  src[i] ;	Uint32 d =   dst[i] ;	unsigned alpha = s >> 24;	Uint32 s1 = s & 0xff00ff;	Uint32 d1 = d & 0xff00ff;	d1 = (d1 + ((s1 - d1) * alpha >> 8)) & 0xff00ff;	s &= 0xff00;	d &= 0xff00;	d = (d + ((s - d) * alpha >> 8)) & 0xff00;	  dst[i]  = d1 | d;	} while(0) ;	}	srcbuf += run * 4;	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	break;
    }
}

 
int SDL_RLEAlphaBlit(SDL_Surface *src, SDL_Rect *srcrect,
		     SDL_Surface *dst, SDL_Rect *dstrect)
{
    int x, y;
    int w = src->w;
    Uint8 *srcbuf, *dstbuf;
    SDL_PixelFormat *df = dst->format;

     
    if ( ( dst ->offset ||	(( dst ->flags & (0x00000001 | 0x00000004 | 0x00004000 )) != 0))  ) {
	if ( SDL_LockSurface(dst) < 0 ) {
	    return -1;
	}
    }

    x = dstrect->x;
    y = dstrect->y;
    dstbuf = (Uint8 *)dst->pixels
	     + y * dst->pitch + x * df->BytesPerPixel;
    srcbuf = (Uint8 *)src->map->sw_data->aux_data + sizeof(RLEDestFormat);

    {
	 
	int vskip = srcrect->y;
	if(vskip) {
	    int ofs;
	    if(df->BytesPerPixel == 2) {
		 
		do {
		     
		    ofs = 0;
		    do {
			int run;
			ofs += srcbuf[0];
			run = srcbuf[1];
			srcbuf += 2;
			if(run) {
			    srcbuf += 2 * run;
			    ofs += run;
			} else if(!ofs)
			    goto done;
		    } while(ofs < w);

		     
		    srcbuf += (unsigned long)srcbuf & 2;

		     
		    ofs = 0;
		    do {
			int run;
			ofs += ((Uint16 *)srcbuf)[0];
			run = ((Uint16 *)srcbuf)[1];
			srcbuf += 4 * (run + 1);
			ofs += run;
		    } while(ofs < w);
		} while(--vskip);
	    } else {
		 
		vskip <<= 1;	 
		do {
		    ofs = 0;
		    do {
			int run;
			ofs += ((Uint16 *)srcbuf)[0];
			run = ((Uint16 *)srcbuf)[1];
			srcbuf += 4;
			if(run) {
			    srcbuf += 4 * run;
			    ofs += run;
			} else if(!ofs)
			    goto done;
		    } while(ofs < w);
		} while(--vskip);
	    }
	}
    }

     
    if(srcrect->x || srcrect->w != src->w) {
	RLEAlphaClipBlit(w, srcbuf, dst, dstbuf, srcrect);
    } else {

	 





//#1309 "SDL_RLEaccel.c"

	switch(df->BytesPerPixel) {
	case 2:
	    if(df->Gmask == 0x07e0 || df->Rmask == 0x07e0
	       || df->Bmask == 0x07e0)
		do {	int linecount = srcrect->h;	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint8  *)srcbuf)[0];	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	do {	if(  sizeof( Uint16 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  run ) )), "1" (  dstbuf + ofs * sizeof( Uint16 )  ), "2" (    srcbuf  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  run ) * (  sizeof( Uint16 ) ) )/4), "q" (  (unsigned)(  run ) * (  sizeof( Uint16 ) ) ), "1" (  dstbuf + ofs * sizeof( Uint16 )  ),"2" (    srcbuf  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint16 );	ofs += run;	} else if(!ofs)	goto done;	} while(ofs < w);	if(sizeof( Uint16 ) == 2)	srcbuf += ((unsigned long)srcbuf) & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	 Uint16  *dst = ( Uint16  *)dstbuf + ofs;	unsigned i;	for(i = 0; i < run; i++) {	Uint32 src = *(Uint32 *)srcbuf;	  do {	Uint32 s =  src ;	Uint32 d =   *dst ;	unsigned alpha = (s & 0x3e0) >> 5;	s &= 0x07e0f81f;	d = (d | d << 16) & 0x07e0f81f;	d += (s - d) * alpha >> 5;	d &= 0x07e0f81f;	  *dst  = d | d >> 16;	} while(0) ;	srcbuf += 4;	dst++;	}	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	    else
		do {	int linecount = srcrect->h;	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint8  *)srcbuf)[0];	run = ((  Uint8  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint8 );	if(run) {	do {	if(  sizeof( Uint16 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  run ) )), "1" (  dstbuf + ofs * sizeof( Uint16 )  ), "2" (    srcbuf  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  run ) * (  sizeof( Uint16 ) ) )/4), "q" (  (unsigned)(  run ) * (  sizeof( Uint16 ) ) ), "1" (  dstbuf + ofs * sizeof( Uint16 )  ),"2" (    srcbuf  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint16 );	ofs += run;	} else if(!ofs)	goto done;	} while(ofs < w);	if(sizeof( Uint16 ) == 2)	srcbuf += ((unsigned long)srcbuf) & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	 Uint16  *dst = ( Uint16  *)dstbuf + ofs;	unsigned i;	for(i = 0; i < run; i++) {	Uint32 src = *(Uint32 *)srcbuf;	  do {	Uint32 s =  src ;	Uint32 d =   *dst ;	unsigned alpha = (s & 0x3e0) >> 5;	s &= 0x03e07c1f;	d = (d | d << 16) & 0x03e07c1f;	d += (s - d) * alpha >> 5;	d &= 0x03e07c1f;	  *dst  = d | d >> 16;	} while(0) ;	srcbuf += 4;	dst++;	}	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	    break;
	case 4:

	if((Hermes_X86_CPU() & 0x800000 )== 0x800000 )

    do {
        int linecount = srcrect->h;
        do {
            int ofs = 0;
            do {
                unsigned run;
                ofs += ((  Uint16  *)srcbuf)[0];
                run = ((  Uint16  *)srcbuf)[1];
                srcbuf += 2 * sizeof(  Uint16 );
                if(run) {
                    do {
                        if(  sizeof( Uint32 )  == 4) {
                            do {
                                int ecx, edi, esi;
                                __asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  run ) )), "1" (  dstbuf + ofs * sizeof( Uint32 )  ), "2" (    srcbuf  )	: "memory" );
                            } while(0) ;
                        } else {
                            do {
                                int u0, u1, u2;
                                __asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  run ) * (  sizeof( Uint32 ) ) )/4), "q" (  (unsigned)(  run ) * (  sizeof( Uint32 ) ) ), "1" (  dstbuf + ofs * sizeof( Uint32 )  ),"2" (    srcbuf  ) : "memory" );
                            } while(0) ;
                        }
                    } while(0) ;
                    srcbuf += run * sizeof( Uint32 );
                    ofs += run;
                } else if(!ofs)
                    goto done;
            } while(ofs < w);

            if(sizeof( Uint32 ) == 2)
                srcbuf += ((unsigned long)srcbuf) & 2;
            ofs = 0;
            do {
                unsigned run;
                ofs += ((Uint16 *)srcbuf)[0];
                run = ((Uint16 *)srcbuf)[1];
                srcbuf += 4;
                if(run) {
                    Uint32  *dst = ( Uint32  *)dstbuf + ofs;
                    unsigned i;
                    for(i = 0; i < run; i++) {
                        Uint32 src = *(Uint32 *)srcbuf;
                        do {	int __tmp = 0x00FF00FF;
                        __asm__ __volatile__ ("movd" " %0, %%" "mm3" : : "X" (   *(&__tmp)  ))  ;
                        __asm__ __volatile__ ("punpckldq" " %" "mm3" ", %" "mm3")  ;
                        __tmp = (Uint32) src  >> 24;
                        __tmp |= (__tmp << 16);
                        __asm__ __volatile__ ("movd" " %0, %%" "mm4" : : "X" (   *(&__tmp)  ))  ;
                        __asm__ __volatile__ ("punpckldq" " %" "mm4" ", %" "mm4")  ;
                        __asm__ __volatile__ ("movd" " %0, %%" "mm1" : : "X" (   *(&(Uint32) src )  ))  ;
                        __asm__ __volatile__ ("punpcklbw" " %" "mm1" ", %" "mm1")  ;
                        __asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm1")  ;
                        __asm__ __volatile__ ("movd" " %0, %%" "mm2" : : "X" (   *(&(Uint32)  *dst )  ))  ;
                        __asm__ __volatile__ ("punpcklbw" " %" "mm2" ", %" "mm2")  ;
                        __asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;
                        __asm__ __volatile__ ("psubw" " %" "mm2" ", %" "mm1")  ;
                        __asm__ __volatile__ ("pmullw" " %" "mm4" ", %" "mm1")  ;
                        __asm__ __volatile__ ("psrlw" " %0, %%" "mm1" : : "X" (   8  ) )  ;
                        __asm__ __volatile__ ("paddw" " %" "mm1" ", %" "mm2")  ;
                        __asm__ __volatile__ ("pand" " %" "mm3" ", %" "mm2")  ;
                        __asm__ __volatile__ ("packuswb" " %" "mm2" ", %" "mm2")  ;
                        __asm__ __volatile__ ("movd" " %%" "mm2" ", %0" : "=X" (    *(&(Uint32)  *dst )  ) :   )  ;
                        __asm__ __volatile__ ("emms") ;	} while(0) ;	srcbuf += 4;	dst++;
                    }
                    ofs += run;
                }
            } while(ofs < w);
            dstbuf += dst->pitch;
        } while(--linecount);
    } while(0) ;






	else

	    do {	int linecount = srcrect->h;	do {	int ofs = 0;	do {	unsigned run;	ofs += ((  Uint16  *)srcbuf)[0];	run = ((  Uint16  *)srcbuf)[1];	srcbuf += 2 * sizeof(  Uint16 );	if(run) {	do {	if(  sizeof( Uint32 )  == 4) {	do {	int ecx, edi, esi;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl"	: "=&c" (ecx), "=&D" (edi), "=&S" (esi)	: "0" ((unsigned)(  (unsigned)(  run ) )), "1" (  dstbuf + ofs * sizeof( Uint32 )  ), "2" (    srcbuf  )	: "memory" );	} while(0) ;	} else {	do {	int u0, u1, u2;	__asm__ __volatile__ (	"cld\n\t"	"rep ; movsl\n\t"	"testb $2,%b4\n\t"	"je 1f\n\t"	"movsw\n"	"1:\ttestb $1,%b4\n\t"	"je 2f\n\t"	"movsb\n"	"2:"	: "=&c" (u0), "=&D" (u1), "=&S" (u2)	: "0" ((unsigned)(  (unsigned)(  run ) * (  sizeof( Uint32 ) ) )/4), "q" (  (unsigned)(  run ) * (  sizeof( Uint32 ) ) ), "1" (  dstbuf + ofs * sizeof( Uint32 )  ),"2" (    srcbuf  ) : "memory" );	} while(0) ;	}	} while(0) ;	srcbuf += run * sizeof( Uint32 );	ofs += run;	} else if(!ofs)	goto done;	} while(ofs < w);	if(sizeof( Uint32 ) == 2)	srcbuf += ((unsigned long)srcbuf) & 2;	ofs = 0;	do {	unsigned run;	ofs += ((Uint16 *)srcbuf)[0];	run = ((Uint16 *)srcbuf)[1];	srcbuf += 4;	if(run) {	 Uint32  *dst = ( Uint32  *)dstbuf + ofs;	unsigned i;	for(i = 0; i < run; i++) {	Uint32 src = *(Uint32 *)srcbuf;	  do {	Uint32 s =  src ;	Uint32 d =   *dst ;	unsigned alpha = s >> 24;	Uint32 s1 = s & 0xff00ff;	Uint32 d1 = d & 0xff00ff;	d1 = (d1 + ((s1 - d1) * alpha >> 8)) & 0xff00ff;	s &= 0xff00;	d &= 0xff00;	d = (d + ((s - d) * alpha >> 8)) & 0xff00;	  *dst  = d1 | d;	} while(0) ;	srcbuf += 4;	dst++;	}	ofs += run;	}	} while(ofs < w);	dstbuf += dst->pitch;	} while(--linecount);	} while(0) ;
	    break;
	}
    }

 done:
     
    if ( ( dst ->offset ||	(( dst ->flags & (0x00000001 | 0x00000004 | 0x00004000 )) != 0))  ) {
	SDL_UnlockSurface(dst);
    }
    return 0;
}

 









 
static int copy_opaque_16(void *dst, Uint32 *src, int n,
			  SDL_PixelFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint16 *d = dst;
    for(i = 0; i < n; i++) {
	unsigned r, g, b;
	{	  r  = ((( *src &  sfmt ->Rmask)>>  sfmt ->Rshift)<<  sfmt ->Rloss);   g  = ((( *src &  sfmt ->Gmask)>>  sfmt ->Gshift)<<  sfmt ->Gloss);   b  = ((( *src &  sfmt ->Bmask)>>  sfmt ->Bshift)<<  sfmt ->Bloss); } ;
	{	 *d  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift);	} ;
	src++;
	d++;
    }
    return n * 2;
}

 
static int uncopy_opaque_16(Uint32 *dst, void *src, int n,
			    RLEDestFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint16 *s = src;
    unsigned alpha = dfmt->Amask ? 255 : 0;
    for(i = 0; i < n; i++) {
	unsigned r, g, b;
	{	  r  = ((( *s &  sfmt ->Rmask)>>  sfmt ->Rshift)<<  sfmt ->Rloss);   g  = ((( *s &  sfmt ->Gmask)>>  sfmt ->Gshift)<<  sfmt ->Gloss);   b  = ((( *s &  sfmt ->Bmask)>>  sfmt ->Bshift)<<  sfmt ->Bloss); } ;
	{	 *dst  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift)|	((  alpha >>  dfmt ->Aloss)<<  dfmt ->Ashift);	} ;
	s++;
	dst++;
    }
    return n * 2;
}



 
static int copy_transl_565(void *dst, Uint32 *src, int n,
			   SDL_PixelFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint32 *d = dst;
    for(i = 0; i < n; i++) {
	unsigned r, g, b, a;
	Uint16 pix;
	{	  r  = ( *src &  sfmt ->Rmask)>>  sfmt ->Rshift;	  g  = ( *src &  sfmt ->Gmask)>>  sfmt ->Gshift;	  b  = ( *src &  sfmt ->Bmask)>>  sfmt ->Bshift;	  a  = ( *src &  sfmt ->Amask)>>  sfmt ->Ashift;	} ;
	{	 pix  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift);	} ;
	*d = ((pix & 0x7e0) << 16) | (pix & 0xf81f) | ((a << 2) & 0x7e0);
	src++;
	d++;
    }
    return n * 4;
}

 
static int copy_transl_555(void *dst, Uint32 *src, int n,
			   SDL_PixelFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint32 *d = dst;
    for(i = 0; i < n; i++) {
	unsigned r, g, b, a;
	Uint16 pix;
	{	  r  = ( *src &  sfmt ->Rmask)>>  sfmt ->Rshift;	  g  = ( *src &  sfmt ->Gmask)>>  sfmt ->Gshift;	  b  = ( *src &  sfmt ->Bmask)>>  sfmt ->Bshift;	  a  = ( *src &  sfmt ->Amask)>>  sfmt ->Ashift;	} ;
	{	 pix  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift);	} ;
	*d = ((pix & 0x3e0) << 16) | (pix & 0xfc1f) | ((a << 2) & 0x3e0);
	src++;
	d++;
    }
    return n * 4;
}

 
static int uncopy_transl_16(Uint32 *dst, void *src, int n,
			    RLEDestFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint32 *s = src;
    for(i = 0; i < n; i++) {
	unsigned r, g, b, a;
	Uint32 pix = *s++;
	a = (pix & 0x3e0) >> 2;
	pix = (pix & ~0x3e0) | pix >> 16;
	{	  r  = ((( pix &  sfmt ->Rmask)>>  sfmt ->Rshift)<<  sfmt ->Rloss);   g  = ((( pix &  sfmt ->Gmask)>>  sfmt ->Gshift)<<  sfmt ->Gloss);   b  = ((( pix &  sfmt ->Bmask)>>  sfmt ->Bshift)<<  sfmt ->Bloss); } ;
	{	 *dst  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift)|	((  a >>  dfmt ->Aloss)<<  dfmt ->Ashift);	} ;
	dst++;
    }
    return n * 4;
}

 
static int copy_32(void *dst, Uint32 *src, int n,
		   SDL_PixelFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint32 *d = dst;
    for(i = 0; i < n; i++) {
	unsigned r, g, b, a;
	Uint32 pixel;
	{	  r  = ( *src &  sfmt ->Rmask)>>  sfmt ->Rshift;	  g  = ( *src &  sfmt ->Gmask)>>  sfmt ->Gshift;	  b  = ( *src &  sfmt ->Bmask)>>  sfmt ->Bshift;	  a  = ( *src &  sfmt ->Amask)>>  sfmt ->Ashift;	} ;
	{	 pixel  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift);	} ;
	*d++ = pixel | a << 24;
	src++;
    }
    return n * 4;
}

 
static int uncopy_32(Uint32 *dst, void *src, int n,
		     RLEDestFormat *sfmt, SDL_PixelFormat *dfmt)
{
    int i;
    Uint32 *s = src;
    for(i = 0; i < n; i++) {
	unsigned r, g, b, a;
	Uint32 pixel = *s++;
	{	  r  = ((( pixel &  sfmt ->Rmask)>>  sfmt ->Rshift)<<  sfmt ->Rloss);   g  = ((( pixel &  sfmt ->Gmask)>>  sfmt ->Gshift)<<  sfmt ->Gloss);   b  = ((( pixel &  sfmt ->Bmask)>>  sfmt ->Bshift)<<  sfmt ->Bloss); } ;
	a = pixel >> 24;
	{	 *dst  = ((  r >>  dfmt ->Rloss)<<  dfmt ->Rshift)|	((  g >>  dfmt ->Gloss)<<  dfmt ->Gshift)|	((  b >>  dfmt ->Bloss)<<  dfmt ->Bshift)|	((  a >>  dfmt ->Aloss)<<  dfmt ->Ashift);	} ;
	dst++;
    }
    return n * 4;
}






 
static int RLEAlphaSurface(SDL_Surface *surface)
{
    SDL_Surface *dest;
    SDL_PixelFormat *df;
    int maxsize = 0;
    int max_opaque_run;
    int max_transl_run = 65535;
    unsigned masksum;
    Uint8 *rlebuf, *dst;
    int (*copy_opaque)(void *, Uint32 *, int,
		       SDL_PixelFormat *, SDL_PixelFormat *);
    int (*copy_transl)(void *, Uint32 *, int,
		       SDL_PixelFormat *, SDL_PixelFormat *);

    dest = surface->map->dst;
    if(!dest)
	return -1;
    df = dest->format;
    if(surface->format->BitsPerPixel != 32)
	return -1;		 

     

    masksum = df->Rmask | df->Gmask | df->Bmask;
    switch(df->BytesPerPixel) {
    case 2:
	 
	switch(masksum) {
	case 0xffff:
	    if(df->Gmask == 0x07e0
	       || df->Rmask == 0x07e0 || df->Bmask == 0x07e0) {
		copy_opaque = copy_opaque_16;
		copy_transl = copy_transl_565;
	    } else
		return -1;
	    break;
	case 0x7fff:
	    if(df->Gmask == 0x03e0
	       || df->Rmask == 0x03e0 || df->Bmask == 0x03e0) {
		copy_opaque = copy_opaque_16;
		copy_transl = copy_transl_555;
	    } else
		return -1;
	    break;
	default:
	    return -1;
	}
	max_opaque_run = 255;	 

	 

	maxsize = surface->h * (2 + (4 + 2) * (surface->w + 1)) + 2;
	break;
    case 4:
	if(masksum != 0x00ffffff)
	    return -1;		 
	copy_opaque = copy_32;
	copy_transl = copy_32;
	max_opaque_run = 255;	 

	 
	maxsize = surface->h * 2 * 4 * (surface->w + 1) + 4;
	break;
    default:
	return -1;		 
    }

    maxsize += sizeof(RLEDestFormat);
    rlebuf = (Uint8 *)malloc(maxsize);
    if(!rlebuf) {
	SDL_Error(SDL_ENOMEM) ;
	return -1;
    }
    {
	 
	RLEDestFormat *r = (RLEDestFormat *)rlebuf;
	r->BytesPerPixel = df->BytesPerPixel;
	r->Rloss = df->Rloss;
	r->Gloss = df->Gloss;
	r->Bloss = df->Bloss;
	r->Rshift = df->Rshift;
	r->Gshift = df->Gshift;
	r->Bshift = df->Bshift;
	r->Ashift = df->Ashift;
	r->Rmask = df->Rmask;
	r->Gmask = df->Gmask;
	r->Bmask = df->Bmask;
	r->Amask = df->Amask;
    }
    dst = rlebuf + sizeof(RLEDestFormat);

     
    {
	int x, y;
	int h = surface->h, w = surface->w;
	SDL_PixelFormat *sf = surface->format;
	Uint32 *src = (Uint32 *)surface->pixels;
	Uint8 *lastline = dst;	 

	 

//#1586 "SDL_RLEaccel.c"

	 



	for(y = 0; y < h; y++) {
	    int runstart, skipstart;
	    int blankline = 0;
	     
	    x = 0;
	    do {
		int run, skip, len;
		skipstart = x;
		while(x < w && ! (((( src[x] ) &   sf ->Amask) >>   sf ->Ashift) == 255) )
		    x++;
		runstart = x;
		while(x < w && (((( src[x] ) &   sf ->Amask) >>   sf ->Ashift) == 255) )
		    x++;
		skip = runstart - skipstart;
		if(skip == w)
		    blankline = 1;
		run = x - runstart;
		while(skip > max_opaque_run) {
		    if(df->BytesPerPixel == 4) {	((Uint16 *)dst)[0] =  max_opaque_run ;	((Uint16 *)dst)[1] =   0 ;	dst += 4;	} else {	dst[0] =  max_opaque_run ;	dst[1] =   0 ;	dst += 2;	} ;
		    skip -= max_opaque_run;
		}
		len = (( run ) < (  max_opaque_run ) ? ( run ) : (  max_opaque_run )) ;
		if(df->BytesPerPixel == 4) {	((Uint16 *)dst)[0] =  skip ;	((Uint16 *)dst)[1] =   len ;	dst += 4;	} else {	dst[0] =  skip ;	dst[1] =   len ;	dst += 2;	} ;
		dst += copy_opaque(dst, src + runstart, len, sf, df);
		runstart += len;
		run -= len;
		while(run) {
		    len = (( run ) < (  max_opaque_run ) ? ( run ) : (  max_opaque_run )) ;
		    if(df->BytesPerPixel == 4) {	((Uint16 *)dst)[0] =  0 ;	((Uint16 *)dst)[1] =   len ;	dst += 4;	} else {	dst[0] =  0 ;	dst[1] =   len ;	dst += 2;	} ;
		    dst += copy_opaque(dst, src + runstart, len, sf, df);
		    runstart += len;
		    run -= len;
		}
	    } while(x < w);

	     
	    dst += (unsigned long)dst & 2;

	     
	    x = 0;
	    do {
		int run, skip, len;
		skipstart = x;
		while(x < w && ! ((unsigned)(((( src[x] ) &   sf ->Amask) >>   sf ->Ashift) - 1U) < 254U) )
		    x++;
		runstart = x;
		while(x < w && ((unsigned)(((( src[x] ) &   sf ->Amask) >>   sf ->Ashift) - 1U) < 254U) )
		    x++;
		skip = runstart - skipstart;
		blankline &= (skip == w);
		run = x - runstart;
		while(skip > max_transl_run) {
		    (((Uint16 *)dst)[0] =  max_transl_run , ((Uint16 *)dst)[1] =   0 , dst += 4) ;
		    skip -= max_transl_run;
		}
		len = (( run ) < (  max_transl_run ) ? ( run ) : (  max_transl_run )) ;
		(((Uint16 *)dst)[0] =  skip , ((Uint16 *)dst)[1] =   len , dst += 4) ;
		dst += copy_transl(dst, src + runstart, len, sf, df);
		runstart += len;
		run -= len;
		while(run) {
		    len = (( run ) < (  max_transl_run ) ? ( run ) : (  max_transl_run )) ;
		    (((Uint16 *)dst)[0] =  0 , ((Uint16 *)dst)[1] =   len , dst += 4) ;
		    dst += copy_transl(dst, src + runstart, len, sf, df);
		    runstart += len;
		    run -= len;
		}
		if(!blankline)
		    lastline = dst;
	    } while(x < w);

	    src += surface->pitch >> 2;
	}
	dst = lastline;		 
	if(df->BytesPerPixel == 4) {	((Uint16 *)dst)[0] =  0 ;	((Uint16 *)dst)[1] =   0 ;	dst += 4;	} else {	dst[0] =  0 ;	dst[1] =   0 ;	dst += 2;	} ;
    }




     
    if((surface->flags & 0x01000000 ) != 0x01000000 
       && (surface->flags & 0x00000001 ) != 0x00000001 ) {
	free( surface->pixels );
	surface->pixels = ((void *)0) ;
    }

     
    {
	Uint8 *p = realloc(rlebuf, dst - rlebuf);
	if(!p)
	    p = rlebuf;
	surface->map->sw_data->aux_data = p;
    }

    return 0;
}

static Uint32 getpix_8(Uint8 *srcbuf)
{
    return *srcbuf;
}

static Uint32 getpix_16(Uint8 *srcbuf)
{
    return *(Uint16 *)srcbuf;
}

static Uint32 getpix_24(Uint8 *srcbuf)
{
    if(1234   == 1234 )
	return srcbuf[0] + (srcbuf[1] << 8) + (srcbuf[2] << 16);
    else
	return (srcbuf[0] << 16) + (srcbuf[1] << 8) + srcbuf[2];
}

static Uint32 getpix_32(Uint8 *srcbuf)
{
    return *(Uint32 *)srcbuf;
}

typedef Uint32 (*getpix_func)(Uint8 *);

static getpix_func getpixes[4] = {
    getpix_8, getpix_16, getpix_24, getpix_32
};

static int RLEColorkeySurface(SDL_Surface *surface)
{
        Uint8 *rlebuf, *dst;
	int maxn;
	int y;
	Uint8 *srcbuf, *curbuf, *lastline;
	int maxsize = 0;
	int skip, run;
	int bpp = surface->format->BytesPerPixel;
	getpix_func getpix;
	Uint32 ckey, rgbmask;
	int w, h;

	 
	switch(bpp) {
	case 1:
	     

	    maxsize = surface->h * 3 * (surface->w / 2 + 1) + 2;
	    break;
	case 2:
	case 3:
	     
	    maxsize = surface->h * (2 * (surface->w / 255 + 1)
				    + surface->w * bpp) + 2;
	    break;
	case 4:
	     
	    maxsize = surface->h * (4 * (surface->w / 65535 + 1)
				    + surface->w * 4) + 4;
	    break;
	}

	rlebuf = (Uint8 *)malloc(maxsize);
	if ( rlebuf == ((void *)0)  ) {
		SDL_Error(SDL_ENOMEM) ;
		return(-1);
	}

	 
	srcbuf = (Uint8 *)surface->pixels;
	curbuf = srcbuf;
	maxn = bpp == 4 ? 65535 : 255;
	skip = run = 0;
	dst = rlebuf;
	rgbmask = ~surface->format->Amask;
	ckey = surface->format->colorkey & rgbmask;
	lastline = dst;
	getpix = getpixes[bpp - 1];
	w = surface->w;
	h = surface->h;


//#1780 "SDL_RLEaccel.c"

	for(y = 0; y < h; y++) {
	    int x = 0;
	    int blankline = 0;
	    do {
		int run, skip, len;
		int runstart;
		int skipstart = x;

		 
		while(x < w && (getpix(srcbuf + x * bpp) & rgbmask) == ckey)
		    x++;
		runstart = x;
		while(x < w && (getpix(srcbuf + x * bpp) & rgbmask) != ckey)
		    x++;
		skip = runstart - skipstart;
		if(skip == w)
		    blankline = 1;
		run = x - runstart;

		 
		while(skip > maxn) {
		    if(bpp == 4) {	((Uint16 *)dst)[0] =  maxn ;	((Uint16 *)dst)[1] =   0 ;	dst += 4;	} else {	dst[0] =  maxn ;	dst[1] =   0 ;	dst += 2;	} ;
		    skip -= maxn;
		}
		len = (( run ) < (  maxn ) ? ( run ) : (  maxn )) ;
		if(bpp == 4) {	((Uint16 *)dst)[0] =  skip ;	((Uint16 *)dst)[1] =   len ;	dst += 4;	} else {	dst[0] =  skip ;	dst[1] =   len ;	dst += 2;	} ;
		memcpy(dst, srcbuf + runstart * bpp, len * bpp);
		dst += len * bpp;
		run -= len;
		runstart += len;
		while(run) {
		    len = (( run ) < (  maxn ) ? ( run ) : (  maxn )) ;
		    if(bpp == 4) {	((Uint16 *)dst)[0] =  0 ;	((Uint16 *)dst)[1] =   len ;	dst += 4;	} else {	dst[0] =  0 ;	dst[1] =   len ;	dst += 2;	} ;
		    memcpy(dst, srcbuf + runstart * bpp, len * bpp);
		    dst += len * bpp;
		    runstart += len;
		    run -= len;
		}
		if(!blankline)
		    lastline = dst;
	    } while(x < w);

	    srcbuf += surface->pitch;
	}
	dst = lastline;		 
	if(bpp == 4) {	((Uint16 *)dst)[0] =  0 ;	((Uint16 *)dst)[1] =   0 ;	dst += 4;	} else {	dst[0] =  0 ;	dst[1] =   0 ;	dst += 2;	} ;



	 
	if((surface->flags & 0x01000000 ) != 0x01000000 
	   && (surface->flags & 0x00000001 ) != 0x00000001 ) {
	    free( surface->pixels );
	    surface->pixels = ((void *)0) ;
	}

	 
	{
	     
	    Uint8 *p = realloc(rlebuf, dst - rlebuf);
	    if(!p)
		p = rlebuf;
	    surface->map->sw_data->aux_data = p;
	}

	return(0);
}

int SDL_RLESurface(SDL_Surface *surface)
{
	int retcode;

	 
	if ( (surface->flags & 0x00004000 ) == 0x00004000  ) {
		SDL_UnRLESurface(surface, 1);
	}

	 
	if ( surface->format->BitsPerPixel < 8 ) {
		return(-1);
	}

	 
	if ( ( surface ->offset ||	(( surface ->flags & (0x00000001 | 0x00000004 | 0x00004000 )) != 0))  ) {
		if ( SDL_LockSurface(surface) < 0 ) {
			return(-1);
		}
	}

	 
	if((surface->flags & 0x00001000 ) == 0x00001000 ) {
	    retcode = RLEColorkeySurface(surface);
	} else {
	    if((surface->flags & 0x00010000 ) == 0x00010000 
	       && surface->format->Amask != 0)
		retcode = RLEAlphaSurface(surface);
	    else
		retcode = -1;	 
	}

	 
	if ( ( surface ->offset ||	(( surface ->flags & (0x00000001 | 0x00000004 | 0x00004000 )) != 0))  ) {
		SDL_UnlockSurface(surface);
	}

	if(retcode < 0)
	    return -1;

	 
	surface->flags |= 0x00004000 ;

	return(0);
}

 





static void UnRLEAlpha(SDL_Surface *surface)
{
    Uint8 *srcbuf;
    Uint32 *dst;
    SDL_PixelFormat *sf = surface->format;
    RLEDestFormat *df = surface->map->sw_data->aux_data;
    int (*uncopy_opaque)(Uint32 *, void *, int,
			 RLEDestFormat *, SDL_PixelFormat *);
    int (*uncopy_transl)(Uint32 *, void *, int,
			 RLEDestFormat *, SDL_PixelFormat *);
    int w = surface->w;
    int bpp = df->BytesPerPixel;

    if(bpp == 2) {
	uncopy_opaque = uncopy_opaque_16;
	uncopy_transl = uncopy_transl_16;
    } else {
	uncopy_opaque = uncopy_transl = uncopy_32;
    }

    surface->pixels = malloc(surface->h * surface->pitch);
     
    (__extension__ (__builtin_constant_p (  surface->h * surface->pitch ) && (  surface->h * surface->pitch ) <= 16	? ((  surface->h * surface->pitch ) == 1	? ({ void *__s = (  surface->pixels  );	*((__uint8_t *) __s) = (__uint8_t)     0  ; __s; }) 	: ({ void *__s = (  surface->pixels  );	union {	unsigned int __ui;	unsigned short int __usi;	unsigned char __uc;	} *__u = __s;	__uint8_t __c = (__uint8_t) (    0  );	switch ((unsigned int) (    surface->h * surface->pitch  ))	{	case 15:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 11:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 7:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 3:	__u->__usi = (unsigned short int) __c * 0x0101;	__u = __extension__ ((void *) __u + 2);	__u->__uc = (unsigned char) __c;	break;	case 14:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 10:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 6:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 2:	__u->__usi = (unsigned short int) __c * 0x0101;	break;	case 13:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 9:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 5:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 1:	__u->__uc = (unsigned char) __c;	break;	case 16:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 12:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 8:	__u->__ui = __c * 0x01010101;	__u = __extension__ ((void *) __u + 4);	case 4:	__u->__ui = __c * 0x01010101;	case 0:	break;	}	__s; }) )	: (__builtin_constant_p (  0 ) && (  0 ) == '\0'	? ({ void *__s = ( surface->pixels ); __builtin_memset ( __s , '\0',     surface->h * surface->pitch  ) ; __s; })	: memset ( surface->pixels ,   0 ,   surface->h * surface->pitch )))) ;

    dst = surface->pixels;
    srcbuf = (Uint8 *)(df + 1);
    for(;;) {
	 
	int ofs = 0;
	do {
	    unsigned run;
	    if(bpp == 2) {
		ofs += srcbuf[0];
		run = srcbuf[1];
		srcbuf += 2;
	    } else {
		ofs += ((Uint16 *)srcbuf)[0];
		run = ((Uint16 *)srcbuf)[1];
		srcbuf += 4;
	    }
	    if(run) {
		srcbuf += uncopy_opaque(dst + ofs, srcbuf, run, df, sf);
		ofs += run;
	    } else if(!ofs)
		return;
	} while(ofs < w);

	 
	if(bpp == 2)
	    srcbuf += (unsigned long)srcbuf & 2;
	
	 
	ofs = 0;
	do {
	    unsigned run;
	    ofs += ((Uint16 *)srcbuf)[0];
	    run = ((Uint16 *)srcbuf)[1];
	    srcbuf += 4;
	    if(run) {
		srcbuf += uncopy_transl(dst + ofs, srcbuf, run, df, sf);
		ofs += run;
	    }
	} while(ofs < w);
	dst += surface->pitch >> 2;
    }
}

void SDL_UnRLESurface(SDL_Surface *surface, int recode)
{
    if ( (surface->flags & 0x00004000 ) == 0x00004000  ) {
	surface->flags &= ~0x00004000 ;

	if(recode && (surface->flags & 0x01000000 ) != 0x01000000 
	   && (surface->flags & 0x00000001 ) != 0x00000001 ) {
	    if((surface->flags & 0x00001000 ) == 0x00001000 ) {
		SDL_Rect full;
		unsigned alpha_flag;

		 
		surface->pixels = malloc(surface->h * surface->pitch);

		 
		SDL_FillRect(surface, ((void *)0) , surface->format->colorkey);

		 
		full.x = full.y = 0;
		full.w = surface->w;
		full.h = surface->h;
		alpha_flag = surface->flags & 0x00010000 ;
		surface->flags &= ~0x00010000 ;  
		SDL_RLEBlit(surface, &full, surface, &full);
		surface->flags |= alpha_flag;
	    } else
		UnRLEAlpha(surface);
	}

	if ( surface->map && surface->map->sw_data->aux_data ) {
	    free(surface->map->sw_data->aux_data);
	    surface->map->sw_data->aux_data = ((void *)0) ;
	}
    }
}


